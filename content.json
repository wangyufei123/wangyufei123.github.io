{"meta":{"title":"随笔小记","subtitle":"Java 前端","description":"一个热爱生活的小开发...","author":"Mr.Wang","url":"http://lwblog.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-05-08T12:45:36.649Z","updated":"2020-05-04T12:57:44.000Z","comments":false,"path":"about/index.html","permalink":"http://lwblog.xyz/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-05-08T12:45:36.649Z","updated":"2020-05-04T12:57:44.000Z","comments":false,"path":"books/index.html","permalink":"http://lwblog.xyz/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-08T13:15:31.896Z","updated":"2020-05-08T13:15:31.896Z","comments":false,"path":"categories/index.html","permalink":"http://lwblog.xyz/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-09T03:19:18.962Z","updated":"2020-05-09T03:19:18.962Z","comments":false,"path":"links/index.html","permalink":"http://lwblog.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-08T12:45:36.651Z","updated":"2020-05-04T12:57:44.000Z","comments":false,"path":"repository/index.html","permalink":"http://lwblog.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-08T13:14:26.998Z","updated":"2020-05-08T13:14:26.998Z","comments":false,"path":"tags/index.html","permalink":"http://lwblog.xyz/tags/index.html","excerpt":"","text":""},{"title":"文章热度排行","date":"2020-05-08T14:28:21.365Z","updated":"2020-05-08T14:28:21.365Z","comments":false,"path":"top/index.html","permalink":"http://lwblog.xyz/top/index.html","excerpt":"","text":"AV.initialize(\"a1SlXAotYrikeQEkob4dUwEO-gzGzoHsz\", \"A9wmspkpn043w1kJDU9CEXgt\"); var time=0; var title=\"\"; var url=\"\"; var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"},{"title":"","date":"2020-05-08T14:21:38.767Z","updated":"2020-05-08T14:21:38.767Z","comments":true,"path":"lib/jquery_lazyload/README.html","permalink":"http://lwblog.xyz/lib/jquery_lazyload/README.html","excerpt":"","text":"jquery-lazyload for NexT Installation Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-jquery-lazyload source/lib/jquery_lazyload Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1lazyload: true Update 12$ cd themes/next/source/lib/jquery_lazyload$ git pull"},{"title":"","date":"2020-05-08T14:21:38.768Z","updated":"2020-05-08T14:21:38.768Z","comments":true,"path":"lib/jquery_lazyload/jquery.scrollstop.js","permalink":"http://lwblog.xyz/lib/jquery_lazyload/jquery.scrollstop.js","excerpt":"","text":"/* http://james.padolsey.com/javascript/special-scroll-events-for-jquery/ */ (function(){ var special = jQuery.event.special, uid1 = \"D\" + (+new Date()), uid2 = \"D\" + (+new Date() + 1); special.scrollstart = { setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } else { evt.type = \"scrollstart\"; jQuery.event.dispatch.apply(_self, _args); } timer = setTimeout( function(){ timer = null; }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid1, handler); }, teardown: function(){ jQuery(this).unbind( \"scroll\", jQuery(this).data(uid1) ); } }; special.scrollstop = { latency: 300, setup: function() { var timer, handler = function(evt) { var _self = this, _args = arguments; if (timer) { clearTimeout(timer); } timer = setTimeout( function(){ timer = null; evt.type = \"scrollstop\"; jQuery.event.dispatch.apply(_self, _args); }, special.scrollstop.latency); }; jQuery(this).bind(\"scroll\", handler).data(uid2, handler); }, teardown: function() { jQuery(this).unbind( \"scroll\", jQuery(this).data(uid2) ); } }; })();"},{"title":"","date":"2020-05-08T14:21:38.767Z","updated":"2020-05-08T14:21:38.767Z","comments":true,"path":"lib/jquery_lazyload/bower.json","permalink":"http://lwblog.xyz/lib/jquery_lazyload/bower.json","excerpt":"","text":"{\"name\":\"jquery_lazyload\",\"version\":\"1.9.4\",\"homepage\":\"http://www.appelsiini.net/projects/lazyload\",\"authors\":[\"Mika Tuupola \"],\"description\":\"jQuery plugin for lazy loading images\",\"main\":[\"jquery.lazyload.js\",\"jquery.scrollstop.js\"],\"license\":\"MIT\",\"ignore\":[\"**/.*\",\"**/*.min.js\",\"**/*.html\",\"**/*.textile\",\"Gruntfile.js\",\"lazyload.jquery.json\",\"package.json\",\"node_modules\",\"bower_components\",\"test\",\"img\"]}"},{"title":"","date":"2020-05-08T14:21:38.768Z","updated":"2020-05-08T14:21:38.768Z","comments":true,"path":"lib/jquery_lazyload/jquery.lazyload.js","permalink":"http://lwblog.xyz/lib/jquery_lazyload/jquery.lazyload.js","excerpt":"","text":"/*! * Lazy Load - jQuery plugin for lazy loading images * * Copyright (c) 2007-2015 Mika Tuupola * * Licensed under the MIT license: * http://www.opensource.org/licenses/mit-license.php * * Project home: * http://www.appelsiini.net/projects/lazyload * * Version: 1.9.7 * */ (function($, window, document, undefined) { var $window = $(window); $.fn.lazyload = function(options) { var elements = this; var $container; var settings = { threshold : 0, failure_limit : 0, event : \"scroll\", effect : \"show\", container : window, data_attribute : \"original\", skip_invisible : false, appear : null, load : null, placeholder : \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" }; function update() { var counter = 0; elements.each(function() { var $this = $(this); if (settings.skip_invisible && !$this.is(\":visible\")) { return; } if ($.abovethetop(this, settings) || $.leftofbegin(this, settings)) { /* Nothing. */ } else if (!$.belowthefold(this, settings) && !$.rightoffold(this, settings)) { $this.trigger(\"appear\"); /* if we found an image we'll load, reset the counter */ counter = 0; } else { if (++counter > settings.failure_limit) { return false; } } }); } if(options) { /* Maintain BC for a couple of versions. */ if (undefined !== options.failurelimit) { options.failure_limit = options.failurelimit; delete options.failurelimit; } if (undefined !== options.effectspeed) { options.effect_speed = options.effectspeed; delete options.effectspeed; } $.extend(settings, options); } /* Cache container as jQuery as object. */ $container = (settings.container === undefined || settings.container === window) ? $window : $(settings.container); /* Fire one scroll event per scroll. Not one scroll event per image. */ if (0 === settings.event.indexOf(\"scroll\")) { $container.bind(settings.event, function() { return update(); }); } this.each(function() { var self = this; var $self = $(self); self.loaded = false; /* If no src attribute given use data:uri. */ if ($self.attr(\"src\") === undefined || $self.attr(\"src\") === false) { if ($self.is(\"img\")) { $self.attr(\"src\", settings.placeholder); } } /* When appear is triggered load original image. */ $self.one(\"appear\", function() { if (!this.loaded) { if (settings.appear) { var elements_left = elements.length; settings.appear.call(self, elements_left, settings); } $(\"\") .bind(\"load\", function() { var original = $self.attr(\"data-\" + settings.data_attribute); $self.hide(); if ($self.is(\"img\")) { $self.attr(\"src\", original); } else { $self.css(\"background-image\", \"url('\" + original + \"')\"); } $self[settings.effect](settings.effect_speed); self.loaded = true; /* Remove image from array so it is not looped next time. */ var temp = $.grep(elements, function(element) { return !element.loaded; }); elements = $(temp); if (settings.load) { var elements_left = elements.length; settings.load.call(self, elements_left, settings); } }) .attr(\"src\", $self.attr(\"data-\" + settings.data_attribute)); } }); /* When wanted event is triggered load original image */ /* by triggering appear. */ if (0 !== settings.event.indexOf(\"scroll\")) { $self.bind(settings.event, function() { if (!self.loaded) { $self.trigger(\"appear\"); } }); } }); /* Check if something appears when window is resized. */ $window.bind(\"resize\", function() { update(); }); /* With IOS5 force loading images when navigating with back button. */ /* Non optimal workaround. */ if ((/(?:iphone|ipod|ipad).*os 5/gi).test(navigator.appVersion)) { $window.bind(\"pageshow\", function(event) { if (event.originalEvent && event.originalEvent.persisted) { elements.each(function() { $(this).trigger(\"appear\"); }); } }); } /* Force initial check if images should appear. */ $(document).ready(function() { update(); }); return this; }; /* Convenience methods in jQuery namespace. */ /* Use as $.belowthefold(element, {threshold : 100, container : window}) */ $.belowthefold = function(element, settings) { var fold; if (settings.container === undefined || settings.container === window) { fold = (window.innerHeight ? window.innerHeight : $window.height()) + $window.scrollTop(); } else { fold = $(settings.container).offset().top + $(settings.container).height(); } return fold = $(element).offset().left + settings.threshold + $(element).width(); }; $.inviewport = function(element, settings) { return !$.rightoffold(element, settings) && !$.leftofbegin(element, settings) && !$.belowthefold(element, settings) && !$.abovethetop(element, settings); }; /* Custom selectors for your convenience. */ /* Use as $(\"img:below-the-fold\").something() or */ /* $(\"img\").filter(\":below-the-fold\").something() which is faster */ $.extend($.expr[\":\"], { \"below-the-fold\" : function(a) { return $.belowthefold(a, {threshold : 0}); }, \"above-the-top\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-screen\": function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-screen\" : function(a) { return !$.rightoffold(a, {threshold : 0}); }, \"in-viewport\" : function(a) { return $.inviewport(a, {threshold : 0}); }, /* Maintain BC for couple of versions. */ \"above-the-fold\" : function(a) { return !$.belowthefold(a, {threshold : 0}); }, \"right-of-fold\" : function(a) { return $.rightoffold(a, {threshold : 0}); }, \"left-of-fold\" : function(a) { return !$.rightoffold(a, {threshold : 0}); } }); })(jQuery, window, document);"}],"posts":[{"title":"Spring_Cloud笔记一","slug":"Spring-Cloud笔记一","date":"2020-09-05T04:47:11.000Z","updated":"2020-09-05T04:50:11.111Z","comments":true,"path":"posts/2e26b41f.html","link":"","permalink":"http://lwblog.xyz/posts/2e26b41f.html","excerpt":"","text":"SpringCloud微服务1. 微服务架构编码构建1.1 IDEA新建project工作空间创建父工程步骤: 微服务cloud整体聚合父工程Project NewProject 聚合总工程名字:cloud2020 Maven选版本:3.6.3 工程名字**** 字符编码 注解生效激活 java编译版本选jdk1.8 File Type过滤填入的代码块： 1*.hprof;*.idea;*.iml;*.pyc;*.pyo;*.rbc;*.yarb;*~;.DS_Store;.git;.hg;.svn;CVS;__pycache__;_svn;vssver.scc;vssver2.scc; 父工程POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;!--表示这是一个pom父工程的文件--&gt; &lt;packaging&gt;pom&lt;&#x2F;packaging&gt; &lt;!-- 统一管理jar包版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;&#x2F;lombok.version&gt; &lt;mysql.version&gt;8.0.19&lt;&#x2F;mysql.version&gt; &lt;druid.version&gt;1.1.16&lt;&#x2F;druid.version&gt; &lt;mybatis.spring.boot.version&gt;1.3.0&lt;&#x2F;mybatis.spring.boot.version&gt; &lt;&#x2F;properties&gt; &lt;!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.2.2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!--spring cloud Hoxton.SR1--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt; &lt;scope&gt;import&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;&#x2F;fork&gt; &lt;addResources&gt;true&lt;&#x2F;addResources&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; Maven工程落地细节复习 Maven中的DependencyManager和dependenciesmaven使用DependencyManager元素来提供了一种管理依赖版本号的方式。==通常会在一个组织或者项目的最顶层的父pom中看到此元素。==使用dependencyManagement可以使所有子项目中引用一个依赖而不用显示列出版本号。Maven会沿父子层级向上走，直到找到dependencyManagement元素的项目 ，然后它就会使用版本号如果某一个子项目需要另外一个版本，加上version即可。如果子项目中声明了版本号，那么使用子项目中的jar包。 ==dependencyManagement只是声明依赖，并不实现引入，一次子项目需要显式的声明需要用的依赖。== * maven中跳过单元测试 父工程创建完成后执行mvn:install将父工程发不到仓库方便子工程继承 1.2 Rest微服务工程构建1.2.1 构建步骤1.2.1.1 Cloud-provider-payment8001微服务提供者支付Module模块 建cloud-provider-payment8001 改pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-provider-payment8001&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;--&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 写yml 1234567891011121314151617server: port: 8001spring: application: name: cloud-payment-service datasource: driver-class-name: com.mysql.cj.jdbc.Driver # serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true url: jdbc:mysql:&#x2F;&#x2F;111.229.203.5:3306&#x2F;db2019?serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false username: weaver password: 192612 type: com.alibaba.druid.pool.DruidDataSourcemybatis: mapperLocations: classpath:mapper&#x2F;*.xml type-aliases-package: com.atguigu.springcloud.entities 主启动 1234567891011121314151617package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;&#x2F;** * @program: cloud2020 * @description: 主启动类 * @author: Mr.Wang * @create: 2020-08-15-22-19 *&#x2F;@SpringBootApplicationpublic class PaymentMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8001.class,args); &#125;&#125; 业务类 建表sql 12345CREATE TABLE &#96;payment&#96; ( &#96;id&#96; BIGINT (20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;, &#96;serial&#96; VARCHAR (200) DEFAULT&#39;&#39;,PRIMARY KEY (id)) ENGINE &#x3D; INNODB AUTO_INCREMENT &#x3D; 1 DEFAULT CHARSET &#x3D; utf8 entitles 主实体Payment 123456789101112131415161718192021package com.atguigu.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;&#x2F;** * @program: cloud2020 * @description: 支付实体类 * @author: Mr.Wang * @create: 2020-08-16-00-08 *&#x2F;@Data@AllArgsConstructor@NoArgsConstructorpublic class Payment implements Serializable &#123; private Long id; private String serial;&#125; son封装体CommonResult 1234567891011121314151617181920212223package com.atguigu.springcloud.entities;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;&#x2F;** * @program: cloud2020 * @description: 穿结果给前端的类 * @author: Mr.Wang * @create: 2020-08-16-00-14 *&#x2F;@Data@AllArgsConstructor@NoArgsConstructorpublic class CommonResult&lt;T&gt; &#123; private Integer code; private String message; private T data; public CommonResult(Integer code,String message)&#123; this(code,message,null); &#125;&#125; dao 接口PaymentDao 123456789101112131415package com.atguigu.springcloud.dao;import com.atguigu.springcloud.entities.Payment;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import org.springframework.web.bind.annotation.RestController;&#x2F;&#x2F;@Repository@Mapperpublic interface PaymentDao &#123; public int create(Payment payment); public Payment getPaymentById(@Param(&quot;id&quot;)Long id);&#125; mybatis的映射文件PaymentMapper.xml 路径：src\\main\\resources\\mapper\\PaymentMapper.xml mapper映射文件 12345678910111213141516&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &#39;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&#39; &#39;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&#39;&gt;&lt;mapper namespace&#x3D;&quot;com.atguigu.springcloud.dao.PaymentDao&quot;&gt; &lt;insert id&#x3D;&quot;create&quot; parameterType&#x3D;&quot;Payment&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt; insert into payment(serial) values (#&#123;serial&#125;); &lt;&#x2F;insert&gt; &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;Payment&quot;&gt; &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;BIGINT&quot;&gt;&lt;&#x2F;id&gt; &lt;result column&#x3D;&quot;serial&quot; property&#x3D;&quot;serial&quot; jdbcType&#x3D;&quot;VARCHAR&quot;&#x2F;&gt; &lt;&#x2F;resultMap&gt; &lt;select id&#x3D;&quot;getPaymentById&quot; parameterType&#x3D;&quot;Long&quot; resultMap&#x3D;&quot;BaseResultMap&quot;&gt; select * from payment where id &#x3D; #&#123;id&#125;; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; service 接口PaymentService 123456789package com.atguigu.springcloud.service;import com.atguigu.springcloud.entities.Payment;import org.apache.ibatis.annotations.Param;public interface PaymentService &#123; public int create(Payment payment); public Payment getPaymentById(Long id);&#125; 实现类 123456789101112131415161718192021222324252627282930package com.atguigu.springcloud.service.impl;import com.atguigu.springcloud.dao.PaymentDao;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: 支付功能的service层 * @author: Mr.Wang * @create: 2020-08-16-00-42 *&#x2F;@Servicepublic class PaymentServiceImpl implements PaymentService &#123; @Resource private PaymentDao paymentDao; @Override public int create(Payment payment) &#123; return paymentDao.create(payment); &#125; @Override public Payment getPaymentById(Long id) &#123; return paymentDao.getPaymentById(id); &#125;&#125; controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.atguigu.springcloud.Controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: 支付的控制层 * @author: Mr.Wang * @create: 2020-08-16-00-48 *&#x2F;@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @PostMapping(value &#x3D; &quot;&#x2F;payment&#x2F;create&quot;) public CommonResult create(Payment payment)&#123; int result &#x3D; paymentService.create(payment); log.info(&quot;****插入结果:&quot;+result); if(result &gt; 0)&#123; return new CommonResult(200,&quot;插入数据库成功&quot;,result); &#125;else&#123; return new CommonResult(444,&quot;插入数据失败&quot;); &#125; &#125; @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id)&#123; Payment payment &#x3D; paymentService.getPaymentById(id); log.info(&quot;****查询结果:&quot;+payment); if(payment !&#x3D; null)&#123; return new CommonResult(200,&quot;查询成功&quot;,payment); &#125;else&#123; return new CommonResult(444,&quot;没有对应记录,查询查询失败&quot;); &#125; &#125;&#125;1.2.1.2 热部署Devtools Adding devtools to your project 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; Adding plugin to your pom.xml下段的配置我们需要粘贴进聚合父类总工程的pom.xml里面 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;&#x2F;fork&gt; &lt;addResources&gt;true&lt;&#x2F;addResources&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt; Enabling automatic build Update the value of使用快捷键command+option+shift+/选择Registry 重启IDEA关闭并重新启动idea开发工具 1.2.1.3 cloud-consumer-order80微服务消费者订单Module模块 建cloud-consumer-order80同8001服务端创建moudle的方法相同 改POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-consumer-order80&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 写YML 12server: port: 80 主启动同上 业务类 RestTemplate是什么RestTemplate提供了多种便捷访问远程Http服务的方法是一种简单便捷的访问restful服务模版累，是Spring提供的用于访问Rest服务的客户端模版工具集 官网及使用官网地址 使用:*使用restTemplate访问restful接口非常的简单粗暴无脑。(url,requestMap,ResponseBean.class)这三个参数分别代表Rest请求地址、请求参数、Http响应转换被转换成对象类型 config配置类 123456789101112131415161718192021package com.atguigu.springcloud.config;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;&#x2F;** * @program: cloud2020 * @description: 配置类 * @author: Mr.Wang * @create: 2020-08-16-20-33 *&#x2F;@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 创建controller 123456789101112131415161718192021222324252627282930313233package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;&#x2F;** * @program: cloud2020 * @description: 订单类web层 * @author: Mr.Wang * @create: 2020-08-16-19-57 *&#x2F;@RestController@Slf4jpublic class OrderController &#123; public static final String PAYMENT_URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8001&quot;; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;create&quot;) public CommonResult&lt;Payment&gt; create(Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;create&quot;,payment,CommonResult.class); &#125; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment(@PathVariable(&quot;id&quot;)Long id)&#123; return restTemplate.getForObject(PAYMENT_URL+&quot;&#x2F;payment&#x2F;get&#x2F;&quot;+id,CommonResult.class); &#125;&#125; 测试 先启动cloud-provider-payment8001 再启动cloud-consumer-order80 idea右下角弹出窗口，选择show，共同管理两个端口号 使用http://localhost/consumer/payment/get/31访问，80为默认端口号可省略不写 不要忘记@RequestBody注解 Run Dashboard的配置 通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口 开启Run DashBoard 12345&lt;option name&#x3D;&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value&#x3D;&quot;SpringBootApplicationConfigurationType&quot; &#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;option&gt; 可能由于idea版本的不同，需要关闭重新启动 1.2.1.4 工程重构 观察问题系统中有重复的部分，需要进行重构 新建-cloud-api-commons pom 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;cn.hutool&#x2F;hutool-all --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt; &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; entities maven命令clean install 订单80和支付8001分别改造 删除各自的原先有过的entities文件夹 各自黏贴pom内容 123456&lt;!--引入自定义的api通用包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 1.2.2 目前工程详图2. Eureka服务注册与发现2.1 Eureka基础知识 什么是服务治理 什么是服务注册Eureka Server 作为服务注册功能的服务器，它是服务注册中心，而系统中其他微服务，使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接，这样系统维护人员就可以通过 Eureka Server来监控各个微服务是否正常运行。在服务注册与发现中有一个注册中心，服务器启动时，会把当前自己的服务器信息比如服务地址，通信地址等注册到注册中心上，另一方（消费者）以别名的方式在注册中心上获取实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。 Eureka两组件 Eureka Server 提供服务注册服务各个微服务节点通过配置启动后，会在 EurekaServer中进行注册，这样 EurekaServer中的服务注册表中将会存储所有可用服务节点的信息。 EurekaClient通过注册中心进行访问是一个Java客户端，用于简化与 Eureka Server的交互，客户端也同时具备一个内置的，使用 轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server 发送心跳（默认周期30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中将这个服务节点移除（默认90秒） 2.2 单机Eureka构建步骤2.2.1 IDEA生成eurekaServer端服务注册中心类似物业公司 建Moudelcloud-eureka-server7001 改POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-eureka-server7001&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 写YML 12345678910111213server: port: 7001eureka: instance: hostname: localhost # eureka服务端实例名称 client: #false表示不向注册中心注册自己 register-with-eureka: false #false表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与 eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F; 主启动 @EnableEurekaServer：声明自己是 eureka 的服务端 12345678910111213141516171819package com.atguitu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;&#x2F;** * @program: cloud2020 * @description: Eureka主启动类 * @author: Mr.Wang * @create: 2020-08-17-14-21 *&#x2F;@SpringBootApplication@EnableEurekaServer &#x2F;&#x2F;表示这个就是注册中心，等级注册public class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; 测试 测试地址:http://localhost:7001 结果页面 2.2.2 EurekaClient端cloud-provider-payment8001将注册进EurekaServer成为服务提供者provider，类似尚硅谷学校对外提供授课服务 建立cloud-provider-payment8001 改POM增加客户端的jar包 12345&lt;!--eureka-client--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 写YML更改8001的yaml配置文件，增加一下配置 123456789eureka: client: #表示是否将自己注册进EurekaServer默认为true register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用 负载均衡 fetch-registry: false service-url: # 入住的地址 defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka 主启动在主启动上添加@EnableEurekaClient注解，表示这个是客户端 测试 先要启动EurekaServer 地址：http://localhost:7001/ 微服务注册名配置说明 自我保护机制 2.2.3 EurekaClient端cloud-consumer-order80将注册进EurekaServer成为服务消费者consumer,类似来尚硅谷上课消费的各位同学 修改cloud-consumer-order80模块 POM文件修改，同8001模块相同 写YML 主启动，同8001模块相同 测试 先要启动EurekaServer,7001服务 在要启动服务提供者provider,8001服务 eureka服务器 http://localhost/consumer/payment/get/31 2.3 集群Eureka构建步骤2.3.1 集群原理说明微服务RPC远程服务调用最核心是什么：高可用，如果注册中心只有一个，出了故障就会导致整个服务环境不可用解决方法：搭建Eureka注册中心集群，实现负载均衡+故障排错集群注册的原理：互相注册，相互守望 2.3.2 EurekaServer集群环境构建步骤 参考cloud-eureka-server7001新建cloud-eureka-server7002 改POM 修改映射配置在系统的hosts文件中添加一下配置 12127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com 写YML(以前单机) 单机的看以前的配置 7001的yml配置文件 12345678910111213server: port: 7001eureka: instance: hostname: 127.0.0.1 # eureka服务端实例名称，集群名字要不同有区分 client: #false表示不向注册中心注册自己 register-with-eureka: false #false表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与 eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http:&#x2F;&#x2F;localhost:7002&#x2F;eureka&#x2F; 7002的yml配置文件 12345678910111213server: port: 7002eureka: instance: hostname: localhost client: #false表示不向注册中心注册自己 register-with-eureka: false #false表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与 eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http:&#x2F;&#x2F;127.0.0.1:7001&#x2F;eureka&#x2F; 主启动 2.3.3 将支付服务8001微服务发布到上面2台Eureka集群配置中yml配置文件的修改 1234567891011121314151617181920212223242526272829server: port: 8001spring: application: name: cloud-payment-service datasource: driver-class-name: com.mysql.cj.jdbc.Driver # serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true url: jdbc:mysql:&#x2F;&#x2F;111.229.203.5:3306&#x2F;db2019?serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false username: weaver password: 192612 type: com.alibaba.druid.pool.DruidDataSourcemybatis: mapperLocations: classpath:mapper&#x2F;*.xml type-aliases-package: com.atguigu.springcloud.entitieseureka: client: #表示是否将自己注册进EurekaServer默认为true register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用 负载均衡 fetch-registry: false service-url: # 入住的地址 #defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka # 集群的配置 defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka,http:&#x2F;&#x2F;localhost:7002&#x2F;eureka 2.3.4 将订单服务80微服务发布到上面2台Eureka集群配置中修改配置同2.3.3 2.3.5 测试01 先要启动EurekaServer，7001/7002服务 再要启动服务提供者provider，8001服务 再要启动消费者，80 http://localhost/consumer/payment/get/31 2.3.6 支付服务提供者8001集群环境构建 参考cloud-provider-payment8001新建cloud-provider-payment8002 改POM 同8001的POM文件一致 写YML 7001 7002 主启动类 修改8001/8002的Controller 8001 123&#x2F;&#x2F; 在各个方法中调用 serverPort 查看端口号@Value(&quot;$&#123;server.port&#125;&quot;)private String serverPort; 8002配置方法同8001 2.3.7 负载均衡 bug 订单服务访问地址不能写死 使用@LoadBalance注解赋予RestTemplate负载均衡的能力 在之前单机版中写死为8001，但是集群后有8001与8002， 进入 http://eureka7001.com:7001/ 查看 8001 与 8002 对应的名称 application 将 PAYMENT_URL 改为 http+application 名 :http://CLOUD-PAYMENT-SERVICE 此时未开启负载均衡不能访问页面：将80端口下的配置类ApplicationContextConfig 下生成的 RestTemplate 的bean方法上添加注解 @LoadBalanced http://localhost/consumer/payment/get/34 访问查看端口号，可以看到在8001与8002之间来回切换 在客户端的yml配置中需要开启对负载均衡的支持 ApplicationContextBean 提前说下Ribbon的负载均衡功能 2.3.8 测试02 先要启动EurekaServer，7001/7002服务 再要启动服务提供者provider，8001/8002服务 http://localhost/consumer/payment/get/31 结果 负载均衡效果达到 8001/8002端口交替出现 Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能了 2.4 actuator微服务信息完善 主机名称：服务名称修改 当前问题 修改cloud-provider-payment8001 修改部分 123instance: instance-id: payment8002 # 自定义主机名 #prefer-ip-address: true # 设置暴露ip地址 完整内容 123456789101112131415161718192021222324252627282930313233server: port: 8002spring: application: #s name: cloud-payment-service datasource: driver-class-name: com.mysql.cj.jdbc.Driver # serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true url: jdbc:mysql:&#x2F;&#x2F;111.229.203.5:3306&#x2F;db2019?serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false username: weaver password: 192612 type: com.alibaba.druid.pool.DruidDataSourcemybatis: mapperLocations: classpath:mapper&#x2F;*.xml type-aliases-package: com.atguigu.springcloud.entitieseureka: client: #表示是否将自己注册进EurekaServer默认为true register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用 负载均衡 fetch-registry: false service-url: # 入住的地址 #defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka # 集群的配置 defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka,http:&#x2F;&#x2F;localhost:7002&#x2F;eureka instance: instance-id: payment8002 # 自定义主机名 prefer-ip-address: true # 设置暴露ip地址 修改之后 访问信息有ip信息提示 当前问题：没有ip提示 修改修改cloud-provider-payment8001 修改部分见上面截图部分 完整内容见上面截图部分 修改之后 2.5 服务发现Discovery 对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息 修改cloud-provider-payment8001的Controller 目前存在一个问题，返回的discoveryClient中不能像视频中一样返回带有服务名称的json串，目前返回的为空 123456789101112131415161718@Resource private DiscoveryClient discoveryClient; @GetMapping(&quot;&#x2F;payment&#x2F;discovery&quot;) public DiscoveryClient discovery()&#123; &#x2F;&#x2F; 得到所有服务名 List&lt;String&gt; services &#x3D; discoveryClient.getServices(); services.forEach(ele-&gt;&#123; log.info(&quot;***service***&quot;+ele); &#125;); &#x2F;&#x2F; 得到服务名对应的信息 List&lt;ServiceInstance&gt; instances &#x3D; discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); instances.forEach(ele-&gt;&#123; log.info(ele.getServiceId()+&quot;\\t&quot;+ele.getHost()+&quot;\\t&quot;+ele.getPort()+&quot;\\t&quot;+ele.getUri()); &#125;); return discoveryClient; &#125; 8001主启动类 8001 主类添加注解 @EnableDiscoveryClient 自测 先要启动EurekaServer，7001/7002服务 再启动8001主启动类，需要稍等一会 http://localhost:8001/payment/discovery 2.6 Eureka自我保护 故障现象 导致原因一句话：某一时刻某一个微服务不可用了，Eureka不会立即清理，依旧会对该微服务的信息进行保存。属于CAP里面的AP分支 为什么会产生自我保护？为了防止 EurekaClient 可以正常运行，但是在 EurekaServer 网络不通的情况下，EurekaServer 不会立刻将 EurekaClient 服务剔除。 什么是自我保护模式？默认情况下，EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90s），但是当网络分区故障发生，微服务与 EurekaServer 之间无法正常通信，以上行为就非常危险。当EurekaServer节点在短时间内丢失过多客户端时，那么这个节点就会进入自我保护模式。 怎么禁止自我保护(一般生产环境中不会禁止自我保护) 注册中心eureakeServer端7001 出厂默认，自我保护机制是开启的eureka.server.enable-self-preservation = true 使用eureka.server.enable-self-preservation = false可以禁用自我保护模式 关闭效果 在eurekaServer端7001处设置关闭自我保护机制 生产者客户端eureakeClient端8001 eureka.instance.lease-renewal-interval-in-seconds=30 eureka.instance.lease-expiration-duration-in-seconds=90 测试 7001和8001都配置完成 先启动7001在启动8001 先关闭8001 马上被删除 3. Zookeeper服务注册与发现3.1 Eureka停止更新了你怎么办https://github.com/Netflix/eureka/wiki 3.2 SpringCloud整合Zookeeper代替Eureka3.2.1 注册中心Zookeeper zookeeper是一个分布式协调工具，可以实现注册中心功能 关闭Linux服务器防火墙后启动zookeeper服务器 zookeeper服务器取代Eureka服务器，zk作为服务注册中心 3.2.2 服务提供者 新建cloud-provider-payment8004 POM 123456789101112131415&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-consumerzk-order80&lt;&#x2F;artifactId&gt;&lt;&#x2F;project&gt; YML 1234567891011# 8004表示注册到zookeeper服务器的支付服务提供端口号server: port: 8004# 服务别名----注册zookeeper到注册中心名称spring: application: name: cloud-provider-payment cloud: zookeeper: connect-string: 49.235.24.12:2181 主启动类 1234567891011121314151617181920package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;&#x2F;** * @program: cloud2020 * @description: zk服务端启动类 * @author: Mr.Wang * @create: 2020-08-18-17-20 *&#x2F;@SpringBootApplication&#x2F;&#x2F;该注解用于向使用consul或者zookeeper作为注册中心时注册服务@EnableDiscoveryClientpublic class PaymentMain8004 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentMain8004.class,args); &#125;&#125; Controller 1234567891011121314151617181920212223242526package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.UUID;&#x2F;** * @program: cloud2020 * @description: 控制层 * @author: Mr.Wang * @create: 2020-08-18-20-32 *&#x2F;@RestController@Slf4jpublic class PaymentController &#123; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;zk&quot;) public String paymentzk()&#123; return &quot;springcloud with zookeeper:&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); &#125;&#125; 启动8004注册进zookeeper 启动后的问题 解决zookeeper半分jar包冲突 排除zk冲突后的新POM 验证测试http://localhost:8004/payment/zk 验证测试2 123456789# 获取服务名[zk: localhost:2181(CONNECTED) 0] ls &#x2F;services[cloud-provider-payment]# 获取流水号[zk: localhost:2181(CONNECTED) 1] ls &#x2F;services&#x2F;cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47]# 获取详细信息[zk: localhost:2181(CONNECTED) 2] get &#x2F;services&#x2F;cloud-provider-payment&#x2F;efc76371-522d-4d5d-8f56-f8fe4deb7a47&#123;&quot;name&quot;:&quot;cloud-provider-payment&quot;,&quot;id&quot;:&quot;efc76371-522d-4d5d-8f56-f8fe4deb7a47&quot;,&quot;address&quot;:&quot;WINDOWS-N0GUAG7&quot;,&quot;port&quot;:8004,&quot;sslPort&quot;:null,&quot;payload&quot;:&#123;&quot;@class&quot;:&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;,&quot;id&quot;:&quot;application-1&quot;,&quot;name&quot;:&quot;cloud-provider-payment&quot;,&quot;metadata&quot;:&#123;&#125;&#125;,&quot;registrationTimeUTC&quot;:1590232919360,&quot;serviceType&quot;:&quot;DYNAMIC&quot;,&quot;uriSpec&quot;:&#123;&quot;parts&quot;:[&#123;&quot;value&quot;:&quot;scheme&quot;,&quot;variable&quot;:true&#125;,&#123;&quot;value&quot;:&quot;:&#x2F;&#x2F;&quot;,&quot;variable&quot;:false&#125;,&#123;&quot;value&quot;:&quot;address&quot;,&quot;variable&quot;:true&#125;,&#123;&quot;value&quot;:&quot;:&quot;,&quot;variable&quot;:false&#125;,&#123;&quot;value&quot;:&quot;port&quot;,&quot;variable&quot;:true&#125;]&#125;&#125; 思考 服务节点是临时还是持久 123456789[zk: localhost:2181(CONNECTED) 18] ls &#x2F;services&#x2F;cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 19] ls &#x2F;services&#x2F;cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 20] ls &#x2F;services&#x2F;cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 21] ls &#x2F;services&#x2F;cloud-provider-payment[][zk: localhost:2181(CONNECTED) 22] 3.2.3 服务消费者 新建cloud-consumerzk-order80 POM同zookeeper服务端配置(8004)相同 YML同zookeeper服务端配置(8004)相同 主启动同zookeeper服务端配置(8004)相同 业务类 123456789101112131415161718192021222324252627282930package com.atguigu.springcloud.controller;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: 控制层 * @author: Mr.Wang * @create: 2020-08-19-09-16 *&#x2F;@RestController@Slf4jpublic class ConsumerController &#123; private static final String INVOKE_URL &#x3D; &quot;http:&#x2F;&#x2F;cloud-provider-payment&quot;; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;zk&quot;) public String paymentInfo()&#123; String result &#x3D; restTemplate.getForObject(INVOKE_URL + &quot;&#x2F;payment&#x2F;zk&quot;, String.class); return result; &#125;&#125; 启动8004注册进zookeeper 验证测试：http://localhost:8004/payment/zk 访问测试地址：http://localhost/consumer/payment/zk 4. Consul服务注册与发现4.1 Consul简介 是什么：https://www.consul.io/intro/index.htmlConsul是一种服务网格解决方案，提供具有服务发现，配置和分段功能的全功能控制平面。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建完整的服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul附带了一个简单的内置代理，因此一切都可以直接使用，还支持Envoy等第三方代理集成。 能干嘛 服务发现：Consul的客户端可以注册服务，例如 api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以轻松找到它们依赖的服务。 运行状况检查：领事客户端可以提供任何数量的运行状况检查，这些检查可以与给定服务（“ Web服务器返回200 OK”）或与本地节点（“内存利用率低于90％”）相关联。操作员可以使用此信息来监视群集的运行状况，服务发现组件可以使用此信息将流量路由到运行状况不佳的主机之外。 KV商店：应用程序可以将Consul的分层键/值存储用于多种目的，包括动态配置，功能标记，协调，领导者选举等。简单的HTTP API使其易于使用。 安全的服务通信：领事可以为服务生成并分发TLS证书，以建立相互TLS连接。 意图 可用于定义允许哪些服务进行通信。可以使用可以实时更改的意图轻松管理服务分段，而不必使用复杂的网络拓扑和静态防火墙规则。 多数据中心：Consul开箱即用地支持多个数据中心。这意味着Consul的用户不必担心会构建其他抽象层以扩展到多个区域。 去哪下：https://www.consul.io/downloads.html 怎么玩：https://www.springcloud.cc/spring-cloud-consul.html 4.2 安装并运行Consul 官网安装说明:https://learn.hashicorp.com/consul/getting-started/install.html 下载完成后只有一个consul.exe文件，硬盘路径下双击运行，查看版本信息 使用开发模式启动 将下载的exe文件双击即可安装 在 exe ==文件的目录==下打开黑窗口 输入 consul –version 检测是否安装成功 启动服务：consul agent -dev 通过 http://localhost:8500/ 访问web界面 4.3 服务提供者 新建Module支付服务provider8006cloud-providerconsul-payment8006 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; YML 1234567891011server: port: 8006spring: application: name: consul-provider-payment cloud: consul: discovery: service-name: $&#123;spring.application.name&#125; host: 111.229.203.5 port: 8500 主启动类 业务类Controller 验证测试：http://localhost:8006/payment/consul 4.4 服务消费者 pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-consumerconsul-order80&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-consul-discovery --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-devtools --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; yml 1234567891011server: port: 80spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 4.5 三个注册中心异同点 CAP C:Consistency(强一致性) A:Availability(可用性) P:Partition tolerance(分区容错) CAP理论关注粒度是数据，而不是整体系统设计的策略 经典CAP图 5. Ribbon负载均衡服务调用5.1 概述 是什么Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套==客户端负载均衡的工具==。简单的说，Ribbonn是Netflix的开源项目，主要功能 是提供==客户端的软件负载均衡算法和服务调用。==Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。就是在配置文件中列出 Loa Balancer后面所有机器，Ribbon会自动帮助你基于某种规则 (如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。 官网资料：https://github.com/Netflix/ribbon/wiki/Getting-Started 能干嘛 LB(负载均衡) 负载均衡(Load Balance)是什么将用户的请求平摊的分配到多个服务上，从而达到HA(高可用)，常见的负载均衡有 Nginx,LVS,硬件 F5等。 Ribbon 本地负载均衡客户端 VS Nginx 服务端负载均衡Nginx 是服务器 负载均衡，客户端所有请求都会交给 nginx，然后由 nginx实现请求转发。即负载均衡是由服务端实现的。Ribbon 是本地负载均衡，在微服务调用接口时，在注册中心上获取注册信息服务列表 之后缓存在JVM本地，从而实现本地RPC远程服务调用技术 前面我们讲解过了80通过轮询负载访问8001/8002 一句话负载均衡+RestTemplate 调用 5.2 Ribbon负载均衡演示 架构说明Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eurake结合之事其中一个实例 Ribbon工作时有两步 第一步先选择 EurekaServer，优先选择统一区域负载较少的 server 第二部再根据用户指定的策略，从server取到的服务注册列表中选择一个地址。其中 Riibon 提供了多种策略（轮询，随机，根据响应时间加权）。 POM不需要引入 RestTemplate的使用 getForObject方法/getForEntity方法getForObject返回对象为响应体中数据转化成的对象，基本上可以理解为jsongetForEntity返回对象为ResponseEntity对象，包含响应中的一些重要信息，比如响应头、响应状态码、响应体 postForObject/postForEntity 123456789@GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;forentity&#x2F;&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPayment1(@PathVariable(&quot;id&quot;) Long id)&#123; ResponseEntity&lt;CommonResult&gt; entity &#x3D; restTemplate.getForEntity(PAYMENT_URL + &quot;&#x2F;payment&#x2F;get&#x2F;&quot; + id, CommonResult.class); if(entity.getStatusCode().is2xxSuccessful())&#123; return entity.getBody(); &#125;else&#123; return new CommonResult(444,&quot;操作失败&quot;); &#125; &#125; GET请求方法 POST请求方法 5.3 Ribbon核心组件IRule IRule:根据特定算法从服务列表中选取一个要访问的服务 RoundRobinRule 轮询 RandomRule 随机 RetryRule 先按照RoundRobinRule的 策略获取服务，如果获取服务失败则在指定时间里进行重试，获取可用服务 WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快，实例选择权重越大 ，越容易被选择 BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器 跳闸状态的服务，然后选择一个并发一个最小的服务 BestAvaibilityFilteringRule 先过滤掉故障实例，再选择并发量较小的实例 ZoneAvoidanceRule 默认规则，符合server所在区域的性能和server的可用性选择服务器 如何替换 修改cloud-consumer-order80 注意配置细节IRule配置类不能放在@ComponentSan 的包及子包下，因为默认的扫描会变成全局负载均衡都按照这样的规则。 新建package:com.atguigu.myrule 上面包下新建MySelfRule规则类 123456789101112131415161718192021package com.atguigu.myrule;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RandomRule;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;&#x2F;** * @program: cloud2020 * @description: 规则类 * @author: Mr.Wang * @create: 2020-08-20-09-12 *&#x2F;@Configurationpublic class MyselfRule &#123; @Bean public IRule myRule()&#123; &#x2F;&#x2F;使用随机的负载均衡 return new RandomRule(); &#125;&#125; 主启动类添加@RibbonClient 123456789101112131415161718192021222324package com.atguigu.springcloud;import com.atguigu.myrule.MyselfRule;import javafx.application.Application;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.ribbon.RibbonClient;&#x2F;** * @program: cloud2020 * @description: 订单类的启动器 * @author: Mr.Wang * @create: 2020-08-16-19-52 *&#x2F;@SpringBootApplication@EnableEurekaClient&#x2F;&#x2F; 选择要接收的服务和配置类@RibbonClient(name&#x3D;&quot;cloud-payment-sesrvice&quot;,configuration &#x3D; MyselfRule.class)public class OrderMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderMain80.class,args); &#125;&#125; 测试 5.4 Ribbon负载均衡算法 原理负载均衡算法：rest接口第几次请求数 % 服务器集群=实际调用服务器位置下标，每次服务重启后rest接口计数从1开始总台数：2台 请求数 调用下标1 1%2=12 2%2=03 3%2=14 4%2=0 RoundRobinRule源码 手写具体详细的请看脑图笔记… 6. OpenFeign服务接口调用6.1 概述 OpenFeign是什么Feign是声明性Web服务客户端。它使编写Web服务客户端更加容易。要使用Feign，请创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，并支持使用HttpMessageConvertersSpring Web中默认使用的注释。Spring Cloud集成了Ribbon和Eureka以及Spring Cloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。https://github.com/spring-cloud/spring-cloud-openfeign 能干嘛 使编写Java Http客户端更加容易使用 RestTemplate+Ribbon 时，利用 RestTemplate 对http 请求的封装处理，形成一套模板化的调用方法，但是在实际中，由于对服务的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以Feign在此基础上做了进一步封装，由他来帮助我们定义和实现服务接口的定义。在==Feign的实现下我们只需要创建一个接口并使用注解来配置它(以前是Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)==。自动封装服务调用客户端的开发量。 Feign集成了Ribbon利用Ribbon维护了Payment的服务列表信息，并且实现了轮询实现客户端的负载均衡。而与Ribbon不同的是，==feign只需要定义服务绑定接口且以声明式的方法==，优雅而简单的实现服务调用 Fegin和OpenFeign两者区别 6.2 OpenFeign使用步骤 接口+注解：微服务调用的接口+@FeignClient 新建cloud-consumer-feign-order80Fegin用在消费端 POM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-order80&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; YML 1234567server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;localhost:7002&#x2F;eureka&#x2F; 主启动类 12345678910111213141516171819202122package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;&#x2F;** * @program: cloud2020 * @description: 主启动类 * @author: Mr.Wang * @create: 2020-08-20-11-24 *&#x2F;@SpringBootApplication@EnableDiscoveryClient&#x2F;&#x2F;激活fengin并使用@EnableFeignClientspublic class OrderfeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderfeignMain80.class,args); &#125;&#125; 业务类 业务逻辑接口+@FeignClient配置调用provider服务 新建PaymentFeignService接口并新政注解@FeignClient 1234567891011121314151617181920package com.atguigu.springcloud.service;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Component&#x2F;** * name:找哪个微服务 *&#x2F; &#x2F;&#x2F; 将业务提供者的名写进去@FeignClient(name&#x3D;&quot;cloud-payment-service&quot;)public interface PaymentFeignService &#123;&#x2F;&#x2F; 将业务提供者的controller路径和方法复制粘贴进来 @GetMapping(value &#x3D; &quot;&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;) public CommonResult getPaymentById(@PathVariable(&quot;id&quot;) Long id);&#125; 控制层Controller 1234567891011121314151617181920212223242526272829package com.atguigu.springcloud.controller;import com.atguigu.springcloud.entities.CommonResult;import com.atguigu.springcloud.entities.Payment;import com.atguigu.springcloud.service.PaymentFeignService;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: 控制层 * @author: Mr.Wang * @create: 2020-08-20-11-36 *&#x2F;@RestController@Slf4jpublic class OrderFeignController &#123; @Resource private PaymentFeignService paymentFeignService; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;get&#x2F;&#123;id&#125;&quot;) public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable(&quot;id&quot;)Long id)&#123; return paymentFeignService.getPaymentById(id); &#125;&#125; 测试 先启动2个Eureka集群7001/7002 在启动2个微服务8001/8002 启动OpenFegin启动 http://localhost/consumer/payment/get/1 Feign自带负载均衡配置项 小总结 6.3 OpenFeign超时控制 超时设置，故意设置超时演示出错情况 服务提供方8001故意写暂停程序 123456789@GetMapping(&quot;&#x2F;payment&#x2F;feign&#x2F;timeout&quot;) public String paymentFeignTimeout()&#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return serverPort; &#125; 服务消费方80添加超时方法PaymentFeginService 服务消费方80添加超时方法OrderFeginController 测试 http://localhost/consumer/payment/feign/timeout 错误页面：==这里需要只启动修改过的服务== OpenFeign默认等待一秒钟，超期后报错 是什么默认Feign客户端只等待一秒钟，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。为了避免这样的情况，有时候我们需要设置客户端的超时控制。 YML文件里需要开启OpenFeign客户端超时控制 1234567891011121314server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;localhost:7002&#x2F;eureka&#x2F;# 添加一下的配置# 设置feign客户端超时时间（openfign默认支持ribbon）ribbon: # 指得失建立链接所用的时间，适用于网络状况正常的情况下。两端链接所用的时间 ReadTimeout: 5000 # 指的是建立链接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 6.4 OpenFeign日志打印功能 日志打印功能 是什么Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节。说白了就是==对Feign接口调用情况进行监控和输出== 日志级别 NONE：默认不显示日志 BASIC：仅记录请求方法，URL，响应状态及执行时间 HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息 FULL：除了HEADERS中定义的信息外，还有请求和响应的正文及元数据 配置日志bean 12345678910111213141516171819package com.atguigu.springcloud.config;import feign.Logger;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;&#x2F;** * @program: cloud2020 * @description: feign的配置类 * @author: Mr.Wang * @create: 2020-08-20-14-52 *&#x2F;@Configurationpublic class FeignLog &#123; @Bean Logger.Level feignLoggerlevel()&#123; return Logger.Level.FULL; &#125;&#125; YML文件里需要开启日期的Feign客户端 1234567891011121314151617server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;localhost:7002&#x2F;eureka&#x2F;# 设置feign客户端超时时间（openfign默认支持ribbon）ribbon: # 指得失建立链接所用的时间，适用于网络状况正常的情况下。两端链接所用的时间 ReadTimeout: 5000 # 指的是建立链接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000logging: level: #feign日志以什么级别监控哪个接口 com.atguigu.springcloud.service.PaymentFeginService: debug 后台日志查看 7. Hystrix断路器7.1 概述 分布式系统面临的问题复杂分布式系统中的应用程序有数十个依赖关系，每个依赖关系在某些时候不可避免的失败。多个微服务之间调用时，假设 A 调B和C，B和C又调其他微服务，就是所谓的扇出。当扇出的链路上某个微服务响应时间过长或不可用对A的调用就会占用越来越多的资源，进而引起系统崩溃 ，所谓的雪崩效应。 是什么Hystrix 是处理分布式系统的延迟和容错的开源库，保证一个依赖出现问题时不会导致整体服务失败，避免级联故障，以提高分布式系统弹性。断路器本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控，向调用方返回一个符合预期的可处理的备选响应，而不是长时间的等待或抛出调用方法无法处理的异常 。 能干嘛 服务降级 服务熔断 接近实时的监控 官网资料：https://github.com/Netflix/Hystrix/wiki/How-To-Use Hystrix官宣，停更进维：https://github.com/Netflix/Hystrix 被动修复bugs 不再接受合并请求 不再发布新版本 7.2 Hystrix重要概念 服务降级服务器忙，请稍后重试，不让客户端等待并立即返回一个友好的提示。fallback 哪些情况会导致服务降级？ 程序运行异常 超时 服务熔断触发服务降级 线程池/信号量打满 服务熔断 类比保险丝达到最大服务访问时，直接拒绝访问，拉闸限电，然后调用服务降级的方法返回友好提示。 服务降级-&gt;进而熔断-&gt;恢复调用链路 服务限流 秒杀高并发等操作，严禁一窝蜂过来拥挤，一秒N个有序进行 7.3 hystrix案例 构建 新建cloud-provider-hystrix-payment8001 POM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-provider-hystrix-payment8001&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; YML 123456789101112server: port: 8001spring: application: name: cloud-provider-hystrix-paymenteureka: client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka register-with-eureka: true fetch-registry: true 主启动 123456789101112131415161718192021package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;&#x2F;** * @program: cloud2020 * @description: 主启动类 * @author: Mr.Wang * @create: 2020-08-20-20-51 *&#x2F;@SpringBootApplication@EnableDiscoveryClient@EnableEurekaClientpublic class PaymentHystrixMain8001 &#123; public static void main(String[] args) &#123; SpringApplication.run(PaymentHystrixMain8001.class,args); &#125;&#125; 业务类 service 1234567891011121314151617181920212223242526272829package com.atguigu.springcloud.service;import ch.qos.logback.core.util.TimeUtil;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;&#x2F;** * @program: cloud2020 * @description: 业务类 * @author: Mr.Wang * @create: 2020-08-20-21-17 *&#x2F;@Servicepublic class PaymentService &#123; &#x2F;&#x2F;正常访问肯定OK的方法 public String paymentInfo_ok(Integer id)&#123; return &quot;线程池:&quot;+Thread.currentThread().getName()+&quot; paymentInfo_ok,id&quot;+id+&quot;\\t&quot;+&quot;哈哈😄&quot;; &#125; public String paymentInfo_timeout(Integer id)&#123; try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池:&quot;+Thread.currentThread().getName()+&quot; paymentInfo_timeout,id&quot;+id+&quot;\\t&quot;+&quot;耗时3秒钟&quot;; &#125;&#125; controller 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: kongzhiceng * @author: Mr.Wang * @create: 2020-08-20-21-22 *&#x2F;@RestController@Slf4jpublic class PaymentController &#123; @Resource private PaymentService paymentService; @Value(&quot;$&#123;server.port&#125;&quot;) private String serverPort; @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;) public String paymentInfo_ok(@PathVariable(&quot;id&quot;) Integer id)&#123; String result &#x3D; paymentService.paymentInfo_ok(id); log.info(&quot;****result&quot;+result); return result; &#125; @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id)&#123; String result &#x3D; paymentService.paymentInfo_timeout(id); log.info(&quot;****result&quot;+result); return result; &#125;&#125; * 正常测试 * 启动eureka7001 * 启动cloud-provider-hystrix-payment8001 * 访问：http://localhost:8001/payment/hystrix/ok/31 * 每次调用耗费5秒钟：http://localhost:8001/payment/hystrix/timeout/31 * 上述module均OK：以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复 高并发测试 上述在非高并发情形下，还能勉强满足 but….. Jmeter压测测试 开启Jmeter,来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务 再来一个访问：http://localhost:8001/payment/hystrix/ok/31、http://localhost:8001/payment/hystrix/timeout/31 看演示结果：两个都在自己转圈圈 为什么会被卡死：tomcat的默认的工作线程数被打满了，没有多余的线程来分解压力和处理。 Jmeter压测结论上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死 看热闹不嫌弃事大，80新建加入 新建cloud-consumer-feign-hystrix-order80 POM 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;&#x2F;artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;artifactId&gt;cloud-consumer-feign-hystrix-order80&lt;&#x2F;artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; YML 12345678server: port: 80eureka: client: register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F; 主启动 12345678910111213141516171819202122package com.atguigu.springcloud;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;&#x2F;** * @program: cloud2020 * @description: 主启动类 * @author: Mr.Wang * @create: 2020-08-20-22-25 *&#x2F;@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class OrderHystrixMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderHystrixMain80.class ,args); &#125;&#125; 业务类 service 12345678910111213141516171819202122package com.atguigu.springcloud.service;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;&#x2F;** * @program: cloud2020 * @description: 服务类 * @author: Mr.Wang * @create: 2020-08-20-22-29 *&#x2F;@Component@FeignClient(name &#x3D; &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;)public interface PaymentHystrixService &#123; @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;) public String paymentInfo_ok(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id);&#125; controller 12345678910111213141516171819202122232425262728293031 package com.atguigu.springcloud.controller; import com.atguigu.springcloud.service.PaymentHystrixService; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; &#x2F;** * @program: cloud2020 * @description: kongzhiceng * @author: Mr.Wang * @create: 2020-08-20-22-42 *&#x2F; @RestController @Slf4j public class PaymentHystirxController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;) public String paymentInfo_ok(@PathVariable(&quot;id&quot;) Integer id)&#123; return paymentHystrixService.paymentInfo_ok(id); &#125; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id)&#123; return paymentHystrixService.paymentInfo_timeout(id); &#125;&#125; 正常测试:http://localhost/consumer/payment/hystrix/ok/31 高并发测试 2W个线程压8001 消费端80微服务再去访问正常的OK微服务8001地址 http://localhost/consumer/payment/hystrix/timeout/31 消费者80:要么转圈圈等待,要么消费端报超时错误 故障现象和导致原因8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕,0此时调用8001，客户端访问响应缓慢，转圈圈 上诉结论正因为有上述故障或不佳表现，才有我们的降级/容错/限流等技术诞生 如何解决，解决的要求 超时导致服务器变慢（转圈:超时不再等待 出错(宕机或程序运行出错):出错要有兜底 解决 对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级 对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级 对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级 7.3.1 服务降级#####7.3.1.1. 降级配置@HystrixCommand#####7.3.1.2. 8001先从自身找问题设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback#####7.3.1.3. 8001fallback 业务类启用@HystrixCommand报异常后如何处理一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法。==代码示例：== 1234567891011121314151617181920&#x2F;** * fallbackmetod：系统异常或者超时后的兜底方案 * commandProperties -&gt; HystrixProperty -&gt; execution.isolation.thread.timeoutInMilliseconds :系统超时的时间 * @param id * @return *&#x2F; @HystrixCommand(fallbackMethod &#x3D; &quot;paymentInfo_timeoutHandler&quot;,commandProperties &#x3D; &#123; @HystrixProperty(name&#x3D;&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value &#x3D; &quot;3000&quot;) &#125;) public String paymentInfo_timeout(Integer id)&#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return &quot;线程池:&quot;+Thread.currentThread().getName()+&quot; paymentInfo_timeout,id&quot;+id+&quot;\\t&quot;+&quot;耗时3秒钟&quot;; &#125; public String paymentInfo_timeoutHandler(Integer id)&#123; return &quot;线程池:&quot;+Thread.currentThread().getName()+&quot; paymentInfo_timeoutHandler,id&quot;+id; &#125; 主启动类激活：添加新注解@EnableCircuitBreaker #####7.3.1.4. 80fallback 80订单微服务，也可以更好的保护自己，自己也依样画葫芦进行客户端降级保护 题外话，切记我们自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务 YML在80的客户端yml文件中添加如下代码配置 123feign: hystrix: enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。 主启动 业务类 12345678910@HystrixCommand(fallbackMethod &#x3D; &quot;paymentTimeoutFallcackMethod&quot;,commandProperties &#x3D;&#123; @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value &#x3D; &quot;1500&quot;) &#125;) @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id)&#123; return paymentHystrixService.paymentInfo_timeout(id); &#125; public String paymentTimeoutFallcackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;消费者客户端80的服务报错了&quot;; &#125; #####7.3.1.5. 目前问题 每个业务方法对应一个兜底的方法，代码膨胀 统一和自定义的分开 #####7.3.1.6. 解决问题 每个方法配置一个？？？膨胀 feign接口系列 @DefaultProperties(defaultFallback = “”)说明:1:1 每个方法配置一个服务降级的方法，技术上可以，实际上操作是不可实现的1:N 除了个别重要核心业务有专属，其它普通的可以通过@DefaultProperties(defaultFallback = &quot;&quot;)统一跳转到统一处理结果页面通用的和独享的各自分开，避免了代码膨胀，合理减少了代码量。 controller配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.atguigu.springcloud.controller;import com.atguigu.springcloud.service.PaymentHystrixService;import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;&#x2F;** * @program: cloud2020 * @description: kongzhiceng * @author: Mr.Wang * @create: 2020-08-20-22-42 *&#x2F;@RestController@Slf4j@DefaultProperties(defaultFallback &#x3D; &quot;payment_Global_FallbaxkMethod&quot;)public class PaymentHystirxController &#123; @Resource private PaymentHystrixService paymentHystrixService; @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;&#123;id&#125;&quot;) public String paymentInfo_ok(@PathVariable(&quot;id&quot;) Integer id)&#123; return paymentHystrixService.paymentInfo_ok(id); &#125; &#x2F;*@HystrixCommand(fallbackMethod &#x3D; &quot;paymentTimeoutFallcackMethod&quot;,commandProperties &#x3D;&#123; @HystrixProperty(name &#x3D; &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value &#x3D; &quot;1500&quot;) &#125;)*&#x2F; @HystrixCommand @GetMapping(&quot;&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;timeout&#x2F;&#123;id&#125;&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id)&#123; return paymentHystrixService.paymentInfo_timeout(id); &#125; public String paymentTimeoutFallcackMethod(@PathVariable(&quot;id&quot;) Integer id)&#123; return &quot;消费者客户端80的服务报错了&quot;; &#125; &#x2F;&#x2F;下面这个是全局的fallback方法 public String payment_Global_FallbaxkMethod()&#123; return &quot;Global异常处理信息，请稍后再是....&quot;; &#125;&#125; 和业务逻辑混在一起？？？混乱 服务降级，客户端去调用服务端，碰上服务端宕机或关闭 本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦 未来我们要面对的异常:运行、超时、宕机 再看我们的业务类PaymentController 修改cloud-consumer-feign-hystrix-order80 根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理 PaymentFallbackService类实现PaymentFeignClientService接口 12345678910111213141516171819 package com.atguigu.springcloud.service; import org.springframework.stereotype.Component; @Component public class PaymentFallbackHystrixService implements PaymentHystrixService&#123; @Override public String paymentInfo_ok(Integer id) &#123; return &quot;------PaymentFallbackHystrixService-------&quot;; &#125; @Override public String paymentInfo_timeout(Integer id) &#123; return &quot;-----PaymentFallbackHystrixService---超时-----&quot;; &#125; &#125; &#96;&#96;&#96; * YML feign: hystrix: enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样。 1* PaymentFeignClientService接口 package com.atguigu.springcloud.service; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; /** * @program: cloud2020 * @description: 服务类 * @author: Mr.Wang * @create: 2020-08-20-22-29 */ @Component @FeignClient(name = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot; ,fallback = PaymentFallbackHystrixService.class) public interface PaymentHystrixService { @GetMapping(&quot;/payment/hystrix/ok/{id}&quot;) public String paymentInfo_ok(@PathVariable(&quot;id&quot;) Integer id); @GetMapping(&quot;/payment/hystrix/timeout/{id}&quot;) public String paymentInfo_timeout(@PathVariable(&quot;id&quot;) Integer id); } 123456789101112131415161718 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyds9vj9zj31js0mqqv5.jpg) * 测试 * 单个eureka先启动7001 * PaymentHystrixMain8001启动 * 正常访问测试：http:&#x2F;&#x2F;localhost&#x2F;consumer&#x2F;payment&#x2F;hystrix&#x2F;ok&#x2F;31 * 故意关闭微服务8001 * 客户端自己调用提升：此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器#### 7.3.2 服务熔断1. 断路器一句话就是家里的保险丝2. 熔断是什么https:&#x2F;&#x2F;martinfowler.com&#x2F;bliki&#x2F;CircuitBreaker.html类比保险丝，达到最大访问后直接拒绝访问，拉闸限电，然后调用服务降级。当检测&#x3D;&#x3D;到该节点微服务调用正常后，恢复调用链路。&#x3D;&#x3D;当失败的调用达到一定阈值，缺省是5s内20次调用失败，就会启动熔断机制。熔断机制的注解是，@HystrixCommand3. 实操 * 修改cloud-provider-hystrix-payment8001 * PaymentService(为什么配置这些参数) /** * 服务熔断 */ @HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = { @HystrixProperty(name=&quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;),//是否开启断路器 @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;,value = &quot;10&quot;),//请求次数 @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value = &quot;10000&quot;),//时间范围 @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;,value = &quot;60&quot;),//失败率达到多少次后跳闸 }) //// 加起来就是在10s内的10次请求中如果失败超过6次进入服务熔断 public String paymentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id){ if(id &lt; 0){ throw new RuntimeException(&quot;*****id 不能为负数&quot;); } String serialNumber = IdUtil.simpleUUID(); return Thread.currentThread().getName()+&quot; \\t 调用成功，流水号&quot;+serialNumber; } public String paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) Integer id){ return &quot;id不能为附属，请稍后在是&quot;; } 1 @GetMapping(“/payment/circuit/{id}”) public String paumentCircuitBreaker(@PathVariable(&quot;id&quot;) Integer id){ String result = paymentService.paymentCircuitBreaker(id); log.info(&quot;*****info&quot;+result); return result; } 1234567891011121314151617181920212223242526272829303132333435 * 测试 * 自测cloud-provider-hystrix-payment8001 * 正确：http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;31 * 错误：http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;-31 * 一次正确一次错误trytry * 重点测试:多次错误,然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行访问，需要慢慢的恢复链路 * 结果：一直输入id为负数，达到失败率后即使输入id为正数也进入错误页面。4. 原理(小结) * 断路器在什么情况下开始起作用 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyfe2vjddj318s0k6tup.jpg) 设计三个参数：时间窗，请求总阈值，错误百分比阈值 1. 快照时间窗：默认为最近的10s 2. 请求总数阈值：必须满足请求总阈值才有资格熔断。默认为20。意味着在10s内，如果命令调用次数不足20次，即使所有请求都超时或其他原因失败断路器都不会打开 3. 错误百分比阈值：在快照时间窗内请求总数超过阈值，且错误次数占总请求次数的比值大于阈值，断路器将会打开 * 断路器开启或者关闭的条件 * 当满足一定阀值的时候（默认10秒内超过20个请求次数） * 当失败率达到一定的时候（默认10秒内超过50%请求失败） * 到达以上阀值，断路器将会开启 * 当开启的时候，所有请求都不会进行转发 * 一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发。如果成功，断路器会关闭，若失败，继续开启。重复4和5 * 断路器打开之后 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyfh27eksj31980cg145.jpg) * all配置:详细的看官网#### 7.3.3 服务限流后面高级篇讲解alibaba的Sentinel说明### 7.4 hystrix工作流程https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;Hystrix&#x2F;wiki&#x2F;How-it-Works### 7.5 服务监控hystrixDashboard* 概述* 仪表盘9001 * 新建cloud-consumer-hystrix-dashboard9001 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghygoe9t00j319m08a111.jpg) * POM &lt;project xmlns=”http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;com.atguigu.springcloud&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumer-hystrix-dashboard9001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--新增hystrix dashboard--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 123* YML&#96;server.port:9001&#96;* HystrixDashboardMain9001+新注解@EnableHystrixDashboard package com.atguigu.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard; /** @program: cloud2020 @description: qidonglei @author: Mr.Wang @create: 2020-08-21-15-37 /@SpringBootApplication@EnableHystrixDashboardpublic class HystrixDashboardMain9001 { public static void main(String[] args) { SpringApplication.run(HystrixDashboardMain9001.class,args); }} 12345678 * 所有Provider微服务提供类（8001&#x2F;8002&#x2F;8003）都需要监控依赖配 * 启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001 http:&#x2F;&#x2F;localhost:9001&#x2F;hystrix* 断路器演示 * 修改cloud-provider-hystrix-payment8001 注意：新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径 Unable to connect to Command Metric Stream 404 @Bean public ServletRegistrationBean getServlet(){ HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 * 监控测试 1. 启动1个eureka或者3个eureka集群均可 2. 观察监控窗口 * 9001监控8001:填写监控地址：http:&#x2F;&#x2F;localhost:8001&#x2F;hystrix.stream ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyhmfgdejj31pw0u0nau.jpg) * 测试地址 * http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;31，http:&#x2F;&#x2F;localhost:8001&#x2F;payment&#x2F;circuit&#x2F;-31 * 结果：测试通过 * 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的：先是成功后是失败 * 如何看 * 7色 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyhwhmruej31de0pqal6.jpg) * 1圈 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyhx2vfjnj319q08c7au.jpg) * 1线：访问趋势 * 整图说明 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyhxzb7d0j31900ji16m.jpg) * 正图说明2 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1ghyhygi7zvj31aa0imk9g.jpg) * 搞懂一个才能看懂复杂的 ## 8. zuul路由网关（没讲）## 9. Gateway新一代网关### 9.1 概述简介1. 官网 * 上一代zuul 1.x:https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;zuul&#x2F;wiki * 当前gateway:https:&#x2F;&#x2F;cloud.spring.io&#x2F;spring-cloud-static&#x2F;spring-cloud-gateway&#x2F;2.2.1.RELEASE&#x2F;reference&#x2F;html&#x2F;2. 是什么Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架3. 能干嘛 * 反向代理 * 鉴权 * 流量控制 * 熔断 * 日志监控4. 微服务架构中网关在哪里![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1gi1nmie3cwj31560jigrc.jpg)![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1gi1nn2t1rhj30qm0ibqcq.jpg)5. 有了zuul怎么又出来gatewayspring cloud gateway具有如下的特性 * 基于Spring Framework5 ,Project Reactor和Spring boot 2.0进行构建的 * 动态路由：能够匹配任何请求属性 * 可以对路由指定Preidcate(断言)和Filter(过滤器) * 集成Hystrix的断路器功能 * 集成Spring Cloud 服务发现功能 * 易于编写的Predicate(断言)和Filter(过滤器) * 请求限流功能 * 支持路径重写### 9.2 三大核心概念1. Route(路由)路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由2. Predicate(断言)参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由3. Filter(过滤)指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。4. 总体web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后进行一些精细化控制。predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器，有了这两个元素，在加上目标uri就可以实现一个具体的路由了### 9.3 Gateway工作流程客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序通过特定于请求的过滤器链来运行请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前和之后运行逻辑。所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行“后”过滤器逻辑。![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1gi1ob6owtrj30cb0gjdfw.jpg)### 9.4 入门配置1. 新建module:&#96;cloud-gateway-gateway9527&#96;2. POM文件 cloud2020 com.atguigu.springcloud 1.0-SNAPSHOT 4.0.0 cloud-gateway-gateway9527 org.springframework.cloud spring-cloud-starter-gateway com.atguigu.springcloud cloud-api-commons 1.0-SNAPSHOT org.springframework.cloud spring-cloud-starter-netflix-hystrix org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.boot spring-boot-devtools runtime true org.projectlombok lombok true org.springframework.boot spring-boot-starter-test test 12 ![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlly1gib5uwic7wj31cs0u07wj.jpg)3. YML配置 server: port: 9527 spring:application: name: cloud-gatewayeureka:instance: hostname: cloud-gateway-serviceclient: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://localhost:7001/eureka1234561. 业务类:无2. 主启动类：同前几个步骤中的主启动类3. 9527网关如何做路由映射 * cloud-provider-payment8001看看controller的访问地址:get&#x2F;lib * 我们目前不想暴露8001端口，希望在8001外面套一层95274. YML新增网关配置 server:port: 9527 spring:application: name: cloud-gatewaycloud: gateway: routes: - id: payment_routh # 路由的ID没有固定规则，但是要求统一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路由匹配进行路由 - id: payment_routh2 uri: http://localhost:8001 predicates: - Path=/payment/lb/**eureka:instance: hostname: cloud-gateway-serviceclient: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://localhost:7001/eureka``` 测试 启动7001 启动8001:cloud-provider-payment8001 启动9527网关 访问说明 添加网关前:http://localhost:8001/payment/get/31 添加网关后:http://localhost:9527/payment/get/31 YML配置说明-gateway网关路由两种配置方式 在yml文件中的配置 代码中注入RouteLocator的Bean 官网案例 百度国内新闻网址，需要外网 自己写一个 百度新闻 业务需求:通过9527网关访问到外网的百度新闻地址 编码1）cloud-gateway-gateway95272) 业务实现 9.5 通过微服务名实现动态路由9.6 Predicate的使用9.7 Filter的使用10. SpringCloud config分布式配置中心10.1 概述10.2 Config服务端配置与测试10.3 Config客户端配置与测试10.4 Config客户端之动态刷新11. SpringCloud Bus 消息总线11.1 概述11.2 RabbitMQ环境配置11.3 SpringCloud Bus动态刷新全局广播11.4 SpringCloud Bus动态刷新定点通知12. SpringCloud Stream消息驱动12.1 消息驱动概述12.2 案例说明12.3 消息驱动之生产者12.4 消息驱动之消费者12.5 分组消费与持久化13. SpringCloud Sleuth分布式请求链路追踪13.1 概述13.2 搭建链路监控步骤14. SpringCloud Alibaba入门简介14.1 why会出现SpringCloud alibaba14.2 SpringCloud alibaba带来了什么？14.3 SpringCloud alibaba学习资料获取15. SpringCloud Alibaba Nacos服务注册和配置中心15.1 Nacos简介15.2 安装并运行Nacos15.3 Nacos作为服务注册中心演示15.4 Nacos作为服务配置中心演示15.5 Nacos集群和持久化配置（重要）16. SpringCloud Alibaba Sentinel实现熔断与限流16.1 Sentinel16.2 安装Sentinel控制台16.3 初始化演示工程16.4 流控规则16.5 降级规则16.6 热点key限流16.7 系统规则16.8 @SentinelResource16.9 服务熔断功能16.10 规则持久化17. SpringCloud Alibaba Seata处理分布式事务17.1 分布式事务问题17.2 Seata简介17.3 Seata-Server安装17.4 订单/库存/账户业务数据库准备17.5 订单/库存/账户业务微服务准备17.6 Test17.7 Seata之原理简介","categories":[],"tags":[]},{"title":"Centos7下静默安装Oracle 11g","slug":"11g","date":"2020-08-23T09:38:23.000Z","updated":"2020-08-23T09:39:36.586Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"http://lwblog.xyz/posts/undefined.html","excerpt":"","text":"[TOC] Centos7下静默安装Oracle 11g(无图形化界面)说明: 因为使用的是静默安装，所以我们不需要安装Linux的图形界面，只需要对Linux进行最小化安装即可 前提准备1. Centos7 的系统环境 系统版本：CentOS Linux release 7.6.1810 (Core) 腾讯云系统 内核版本： 系统配置 交换空间 因为腾讯云的原因，默认是不提供swap分区的，这里需要自己手动添加一下。在别的系统上可以视情况而定。如果没有swap的分区的，在安装数据库的时候会出现报错。 12345dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swap bs&#x3D;1024 count&#x3D;2048000mkswap &#x2F;swapchmod 600 &#x2F;swapswapon &#x2F;swapecho &quot;&#x2F;swap swap swap default 0 0&quot;&gt;&gt;&#x2F;etc&#x2F;fstab #设置成自动挂载 2.配置hostname此步骤不是必须滴 12hostnamectl set-hostname oracledbecho &quot;127.0.0.1 oracledb&quot; &gt;&gt;&#x2F;etc&#x2F;hosts 3.关闭selinux此步骤可以视情况而定，本次案例安装的时候执行了此命令 12sed -i &quot;s&#x2F;SELINUX&#x3D;enforcing&#x2F;SELINUX&#x3D;disabled&#x2F;&quot; &#x2F;etc&#x2F;selinux&#x2F;config setenforce 0 2. 下载Oracle官网下载地址根据自己的服务器，下载相应的软件，我的系统是centos7 64位的，所以下载是Linux x86-64的，下载完成后的两个文件如下: linux.x64_11gR2_database_1of2.zip linux.x64_11gR2_database_2of2.zip 说明:*Oracle系统下载的时候请下载Linux x86-64位的系统，请不要下载zlinux，zlinux是IBM的操作系统的一bai个版本。zLinux就是在baiIBM大机上装Linux，目前主要有RedHat与SUSE for z 3.检查软件依赖环境注意：从Oracle 11g 11.2.0.2版本开始，在Linux x86_64上安装时，只需要安装64位的软件包，但是，对于11.2.0.2之前的任何Oracle database 11g,下表中列出的32位和64位的安装包都必须安装 需要安装的依赖包(版本号只能大于规定的版本，不能小于) 12345678910111213141516171819202122232425262728293031binutils-2.23.52.0.1-12.el7.x86_64 compat-libcap1-1.10-3.el7.x86_64 compat-libstdc++-33-3.2.3-71.el7.i686compat-libstdc++-33-3.2.3-71.el7.x86_64gcc-4.8.2-3.el7.x86_64 gcc-c++-4.8.2-3.el7.x86_64 glibc-2.17-36.el7.i686 glibc-2.17-36.el7.x86_64 glibc-devel-2.17-36.el7.i686 glibc-devel-2.17-36.el7.x86_64 kshlibaio-0.3.109-9.el7.i686 libaio-0.3.109-9.el7.x86_64 libaio-devel-0.3.109-9.el7.i686 libaio-devel-0.3.109-9.el7.x86_64 libgcc-4.8.2-3.el7.i686 libgcc-4.8.2-3.el7.x86_64 libstdc++-4.8.2-3.el7.i686 libstdc++-4.8.2-3.el7.x86_64 libstdc++-devel-4.8.2-3.el7.i686 libstdc++-devel-4.8.2-3.el7.x86_64 libXi-1.7.2-1.el7.i686 libXi-1.7.2-1.el7.x86_64 libXtst-1.2.2-1.el7.i686 libXtst-1.2.2-1.el7.x86_64 make-3.82-19.el7.x86_64 sysstat-10.1.5-1.el7.x86_64unixODBC-2.3.1-6.el7.i686unixODBC-2.3.1-6.el7.x86_64unixODBC-devel-2.3.1-6.el7.i686unixODBC-devel-2.3.1-6.el7.x86_64 安装命令 1yum -y install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-devel 安装完成后，检查依赖是否安装成功 1rpm -q binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel libXi libXtst make sysstat unixODBC unixODBC-devel | grep &quot;not installed&quot; 注：本次安装使用的是腾讯云的centos服务器，腾讯云的yum源已经有了。如果您使用的是其他环境，缺少那个依赖包，就手动下载安装即可。 4. 创建所需的操作系统组和用户如果要安装Oracle数据库，则需要以下本地操作系统组和用户: Oracle inventory组(通常为 oinstall) OSDBA组 (通常为 dba) OSOPER组 (通常为 oper) Oracle软件所有者(通常为 oracle) 添加命令 1234groupadd oinstallgroupadd dbagroupadd operuseradd -g oinstall -G dba,oper oracle 添加完成后，查看oracle用户 1id oracle 修改oracle用户密码 1passwd oracle 5. 配置内核参数和资源限制 在/etc/sysctl.conf添加如下的参数，如果系统中某个参数高于下面的参数的值。保留较大的值，下面的数值之事官方要求的最小值。可以根据系统调整数值。以优化系统性能。具体参数说明请详见[内核参数说明](# 6.内核参数说明) 12345678910111213vim &#x2F;etc&#x2F;sysctl.conffs.aio-max-nr &#x3D; 1048576fs.file-max &#x3D; 6815744kernel.shmall &#x3D; 2097152kernel.shmmax &#x3D; 536870912kernel.shmmni &#x3D; 4096kernel.sem &#x3D; 250 32000 100 128net.ipv4.ip_local_port_range &#x3D; 9000 65500net.core.rmem_default &#x3D; 262144net.core.rmem_max &#x3D; 4194304net.core.wmem_default &#x3D; 262144net.core.wmem_max &#x3D; 1048576 使内核参数生效 1sysctl -p 或者执行：&#x2F;sbin&#x2F;sysctl -p 在/etc/security/limits.conf中添加如下参数 1234567vim &#x2F;etc&#x2F;security&#x2F;limits.conforacle soft nproc 2047oracle hard nproc 16384oracle soft nofile 1024oracle hard nofile 65536oracle soft stack 10240 在/etc/pam.d/login文件中，添加下面内容 12session required &#x2F;lib64&#x2F;security&#x2F;pam_limits.sosession required pam_limits.so /etc/profile文件中添加如下内容 12345678if [ $USER &#x3D; &quot;oracle&quot; ]; then if [ $SHELL &#x3D; &quot;&#x2F;bin&#x2F;ksh&quot; ]; then ulimit -p 16384 ulimit -n 65536 else ulimit -u 16384 -n 65536 fifi 使用/etc/profile文件生效 1source &#x2F;etc&#x2F;profile 禁用使用Transparent HugePages(启用Transparent HugePages,可能会导致造成内存在运行时的延迟分配，Oracle官方建议使用标准的HugePages) 查看是否启用 如果显示 [always]说明启用了 1cat &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled 禁用Transparent HugePages,在/etc/grub.conf添加如下内容 1echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled 重启系统以使更改成为永久更改：reboot 6.内核参数说明 fs.aio-max-nr:同时可以拥有的的异步IO请求数目。1048576 即 1024*1024 也就是 1024K 个 fs.file-max:系统允许打开的文件数。 kernel.shmall:设置共享内存总页数。这个值太小有可能导致数据库启动报错,计算公式为：内存（G）* 1024 1024*1024/4096,4096为getconfPAGE_SIZE得到分页大小 kernel.shmmax:Linux进程可以分配的单独共享内存段的最大值。一般设置为内存总大小的一半。这个值的设置应该大于SGA_MAX_TARGET或MEMORY_MAX_TARGET的值，因此对于安装Oracle数据库的系统，shmmax的值应该比内存的二分之一大一些。 kernel.shmmni:设置系统级最大共享内存段数量。推荐最小值为4096 kernel.sem:从左到右分别为SEMMSL、SEMMNS、SEMOPM和SEMMNI。 SEMMSL:设置每个信号灯组中信号灯最大数量，推荐的最小值是250。对于系统中存在大量并发连接的系统，推荐将这个值设置为PROCESSES初始化参数加10 SEMMNS:设置系统中信号灯的最大数量。操作系统在分配信号灯时不会超过LEAST(SEMMNS,SEMMSLSEMMNI)。事实上，如果SEMMNS的值超过了SEMMSLSEMMNI是非法的，因此推荐SEMMNS的值就设置为SEMMSLSEMMNI。Oracle推荐SEMMNS的设置不小于32000，假如数据库的PROCESSES参数设置为600，则SEMMNS的设置应为：SQL&gt; select (600+10)142 from dual;(600+10)*142/86620 SEMOPM:设置每次系统调用可以同时执行的最大信号灯操作的数量。由于一个信号灯组最多拥有SEMMSL个信号灯，因此有推荐将SEMOPM设置为SEMMSL的值。Oracle验证的10.2和11.1的SEMOPM的配置为100。 SEMMNI:设置系统中信号灯组的最大数量。Oracle10g和11g的推荐值为142 net.ipv4.ip_local_port_range:ip_local_port_range表示端口的范围，为指定的内容 net.core.rmem_default:表示接收套接字缓冲区大小的缺省值（以字节为单位）。 net.core.rmem_max:表示接收套接字缓冲区大小的最大值（以字节为单位） net.core.wmem_default:表示发送套接字缓冲区大小的缺省值（以字节为单位） net.core.wmem_max:表示发送套接字缓冲区大小的最大值（以字节为单位） 7. 创建oracle安装目录如下目录，可以根据自己的实际情况可做修改。我这里使用的是/u01作为根目录的，这样在以后的配置的时候感觉会省很多的事情。主要也是为了与公司产品数据库安装的时候配置路径保持一致。 123456mkdir -p &#x2F;u01&#x2F;app&#x2F;oracle mkdir -p &#x2F;u01&#x2F;app&#x2F;oraInventorychown -R oracle:oinstall &#x2F;u01&#x2F;chown -R oracle:oinstall &#x2F;u01&#x2F;app&#x2F;oraclechown -R oracle:oinstall &#x2F;u01&#x2F;app&#x2F;oraInventorychmod -R 775 &#x2F;u01&#x2F; 部分路径说明 ./app/oracle/product/11.2.0 ：数据库系统安装目录 ./app/oracle/backup：数据备份目录 ./app/oracle/oraInventory：清单目录 8. 配置oracle用户环境变量在文件~/.bash_profile里添加下面的内容(具体值根据实际情况修改)切换到oracle用户:su - oracle 12345678TMP&#x3D;&#x2F;tmp; export TMPTMPDIR&#x3D;$TMP; export TMPDIRORACLE_UNQNAME&#x3D;ecology; export ORACLE_UNQNAMEORACLE_BASE&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle; export ORACLE_BASEORACLE_HOME&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1; export ORACLE_HOMEORACLE_SID&#x3D;ecology; export ORACLE_SIDPATH&#x3D;$PATH:&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin; export PATHLD_LIBRARY_PATH&#x3D;&#x2F;lib:&#x2F;lib:&#x2F;usr&#x2F;lib:$ORACLE_HOME&#x2F;lib; exoprt LD_LIBRARY_PATH 9. 重启一下系统1reboot 10. 解压下载好的两个Oracle数据库解压的顺序需要注意一下，先解压一，然后在解压二将上传到系统的oracle安装包解压到上边新建的/u01路径下 12unzip -q linux.x64_11gR2_database_1of2.zip -d &#x2F;u01unzip -q linux.x64_11gR2_database_2of2.zip -d &#x2F;u01 创建一个新的文件夹，将解压后的应答文件放到新建的文件夹中,或者是在原路径下copy一份文件，最好是不要在原文件上修改 123456mkdir -p &#x2F;data&#x2F;etc# 复制响应文件cp &#x2F;u01&#x2F;database&#x2F;response&#x2F;* &#x2F;data&#x2F;etc&#x2F;#设置响应文件权限su - rootchmod 700 &#x2F;data&#x2F;etc&#x2F;*.rsp 复制到/data/etc目录下的文件作用 db_install.rsp:安装应答 dbca.rsp：创建数据库应答 netca.rsp:建立监听、本地服务名等网络设置应答 特别是组件配置事后请用如右语句查询核实(select comp_id, comp_name, version, status from dba_registry) 在/data/etc/db_install.rsp修改以下变量的值在配置对应的文件前，请先阅读 11.db_install.rsp应答文件参数说明 1234567891011121314cd &#x2F;data&#x2F;etc&#x2F;vim db_install.rsporacle.install.option&#x3D;INSTALL_DB_SWONLYORACLE_HOSTNAME&#x3D;xiaofeifei #用hostname命令查看UNIX_GROUP_NAME&#x3D;oinstallINVENTORY_LOCATION&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;inventorySELECTED_LANGUAGES&#x3D;en,zh_CNORACLE_HOME&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1ORACLE_BASE&#x3D;&#x2F;u01&#x2F;app&#x2F;oracleoracle.install.db.InstallEdition&#x3D;EEoracle.install.db.DBA_GROUP&#x3D;dbaoracle.install.db.OPER_GROUP&#x3D;dbaDECLINE_SECURITY_UPDATES&#x3D;true 11.db_install.rsp应答文件参数说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253oracle.install.responseFileVersion&#x3D;&#x2F;oracle&#x2F;install&#x2F;rspfmt_dbinstall_response_schema_v11_2_0&#x2F;&#x2F;标注响应文件版本.注解文件版本，这个版本必须和要＃安装的数据库版本相同，安装检验无法通过，不能更改 oracle.install.option&#x3D;INSTALL_DB_SWONLY #INSTALL_DB_SWONLY:只装数据库软件;INSTALL_DB_AND_CONFIG:安装数据库软件并建库;UPGRADE_DB:升级数据库 ORACLE_HOSTNAME&#x3D;主机名 #指定操作系统主机名，通过hostname 命令获得 UNIX_GROUP_NAME&#x3D;oinstall&#x2F;&#x2F;指定oracle inventory目录的所有者 INVENTORY_LOCATION&#x3D;&#x2F;u01&#x2F;app&#x2F;oraInventory指定产品清单oracle inventory目录的路径，win平台下可以生路 SELECTED_LANGUAGES&#x3D;en,zh_CN&#x2F;&#x2F;指定语言,可以选择多个，用逗号隔开。选择en, zh_CN(英文和简体中文) ORACLE_HOME&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_home1&#x2F;&#x2F;设置ORALCE_HOME的路径 ORACLE_BASE&#x3D;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;&#x2F;指定ORALCE_BASE的路径 oracle.install.db.InstallEdition&#x3D;EE&#x2F;&#x2F;安装数据库软件的版本，EE:企业版;SE:标准版；SEONE：标准版1 oracle.install.db.EEOptionsSelection&#x3D;true&#x2F;&#x2F;手动指定企业安装组件 选true对安装大小影响不大所以选true oracle.install.db.optionalComponents&#x3D;oracle.rdbms.partitioning:11.2.0.4.0,oracle.oraolap:11.2.0.4.0,oracle.rdbms.dm:11.2.0.4.0,oracle.rdbms.dv:11.2.0.4.0,oracle.rdbms.lbac:11.2.0.4.0,oracle.rdbms.rat:11.2.0.4.0&#x2F;&#x2F;如果上面选true，这些就是手动指定的组件 oracle.install.db.DBA_GROUP&#x3D;dba&#x2F;&#x2F;指定拥有DBA用户组，通常会是dba组 oracle.install.db.OPER_GROUP&#x3D;oper&#x2F;&#x2F;指定oper用户组 oracle.install.db.CLUSTER_NODES&#x3D;&#x2F;&#x2F;指定所有的节点 oracle.install.db.isRACOneInstall&#x3D;false&#x2F;&#x2F;是否是RACO方式安装 oracle.install.db.racOneServiceName&#x3D; oracle.install.db.config.starterdb.type&#x3D;&#x2F;&#x2F;选择数据库的用途，一般用途&#x2F;事物处理，数据仓库 oracle.install.db.config.starterdb.globalDBName&#x3D;指定GlobalName oracle.install.db.config.starterdb.SID&#x3D;&#x2F;&#x2F;你指定的SID oracle.install.db.config.starterdb.characterSet&#x3D;AL32UTF8&#x2F;&#x2F;设置数据库编码 oracle.install.db.config.starterdb.memoryOption&#x3D;true&#x2F;&#x2F;11g的新特性自动内存管理，也就是SGA_TARGET和PAG_AGGREGATE_TARGET都，不用设置了，Oracle会自动调配两部分大小，这个要选true oracle.install.db.config.starterdb.memoryLimit&#x3D;上面是true的情况下，指定Oracle自动管理内存的大小，这里不用填或者填写物理内存的40%左右等等自定义； oracle.install.db.config.starterdb.installExampleSchemas&#x3D;false是否载入模板示例 oracle.install.db.config.starterdb.enableSecuritySettings&#x3D;true 是否启用安全设置 oracle.install.db.config.starterdb.password.ALL&#x3D;123456所有用户名的密码 oracle.install.db.config.starterdb.password.SYS&#x3D; oracle.install.db.config.starterdb.password.SYSTEM&#x3D; oracle.install.db.config.starterdb.password.SYSMAN&#x3D; oracle.install.db.config.starterdb.password.DBSNMP&#x3D; oracle.install.db.config.starterdb.control&#x3D;DB_CONTROL数据库本地管理工具DB_CONTROL，远程集中管理工具GRID_CONTROL oracle.install.db.config.starterdb.gridcontrol.gridControlServiceURL&#x3D;GRID_CONTROL需要设定grid control的远程路径URL oracle.install.db.config.starterdb.automatedBackup.enable&#x3D;false设置自动备份 oracle.install.db.config.starterdb.automatedBackup.osuid&#x3D;.自动备份会启动一个job，指定启动JOB的系统用户ID oracle.install.db.config.starterdb.automatedBackup.ospwd&#x3D;自动备份会开启一个job，需要指定OSUser的密码 oracle.install.db.config.starterdb.storageType&#x3D;要求指定使用的文件系统存放数据库文件还是ASM oracle.install.db.config.starterdb.fileSystemStorage.dataLocation&#x3D;使用文件系统存放数据库文件才需要指定数据文件、控制文件、Redo log的存放目录 oracle.install.db.config.starterdb.fileSystemStorage.recoveryLocation&#x3D;使用文件系统存放数据库文件才需要指定备份恢复目录 oracle.install.db.config.asm.diskGroup&#x3D;使用ASM存放数据库文件才需要指定存放的磁盘组 oracle.install.db.config.asm.ASMSNMPPassword&#x3D;使用ASM存放数据库文件才需要指定ASM实例密码 MYORACLESUPPORT_USERNAME&#x3D;指定metalink账户用户名 MYORACLESUPPORT_PASSWORD&#x3D;指定metalink账户密码 SECURITY_UPDATES_VIA_MYORACLESUPPORT&#x3D;用户是否可以设置metalink密码 DECLINE_SECURITY_UPDATES&#x3D;true是否设置安全更新， PROXY_HOST&#x3D;代理服务器名 PROXY_PORT&#x3D;代理服务器端口 PROXY_USER&#x3D;代理服务器用户名 PROXY_PWD&#x3D;代理服务器密码 PROXY_REALM&#x3D; COLLECTOR_SUPPORTHUB_URL&#x3D; oracle.installer.autoupdates.option&#x3D;SKIP_UPDATES 自动更新 oracle.installer.autoupdates.downloadUpdatesLoc&#x3D;自动更新下载目录 AUTOUPDATES_MYORACLESUPPORT_USERNAME&#x3D;自动更新的用户名 AUTOUPDATES_MYORACLESUPPORT_PASSWORD&#x3D;自动更新的密码 12. 开始安装开始安装的命令: 123su - oraclecd &#x2F;u01&#x2F;database.&#x2F;runInstaller -silent -responseFile &#x2F;data&#x2F;etc&#x2F;db_install.rsp -ignorePrereq 安装期间可以使用tail命令监看oracle的安装日志 12#日志文件名称根据自己的实际执行时间变更,这里的日志文件会在界面上打出，直接粘贴复制就OKtail -f &#x2F;data&#x2F;app&#x2F;oracle&#x2F;inventory&#x2F;logs&#x2F;installActions2019-01-02_06-03-30PM.log 安装完成后有如下的提示，如果有类似的提示，说明安装完成 123456789101112131415You can find the log of this install session at: &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;inventory&#x2F;logs&#x2F;installActions2020-08-23_12-42-59AM.logThe following configuration scripts need to be executed as the &quot;root&quot; user. #!&#x2F;bin&#x2F;sh #Root scripts to run&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;inventory&#x2F;orainstRoot.sh&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;root.shTo execute the configuration scripts: 1. Open a terminal window 2. Log in as &quot;root&quot; 3. Run the scripts 4. Return to this window and hit &quot;Enter&quot; key to continue Successfully Setup Software. 日志部分内容说明 13. 使用root用户执行对应的脚本123su - rootsh &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;inventory&#x2F;orainstRoot.shsh &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;root.sh 14. 配置监听程序12su - oraclenetca &#x2F;silent &#x2F;responsefile &#x2F;data&#x2F;etc&#x2F;netca.rsp 注意：这里使用的命令是:netca /silent /responsefile /data/etc/netca.rsp而不是使用的netca -silent -responseFile /home/oracle/database/response/netca.rsp否则会报出如下的错误 12345****DISPLAY environment variable not set! Oracle Net Configuration Assistant is a GUI tool which requires that DISPLAY specify a location where GUI tools can display. Set and export DISPLAY, then re-run. 如果使用的是xmanage的连接工具，可以使用如下的命令进行设置(这个没有进行测试过) 123解决方法：export DISPLAY&#x3D;192.168.8.146:0.0export DISPLAY&#x3D;自己的ip:0.0也有说的是把0.0改成1.0具体情况需要可以进行百度，网上有好多的处理方法 查看监听端口： 1234netstat -tnpl | grep 1521[oracle@xiaofeifei database]$ netstat -tnpl | grep 1521tcp6 0 0 :::1521 :::* LISTEN 8943&#x2F;tnslsnr 15. 静默创建数据库 编辑应答文件/data/etc/dbca.rsp，部分参数说明请详见 [16.静默创建数据库部分参数说明](# 16. 静默创建数据库部分参数说明) 12345678GDBNAME &#x3D; &quot;ecology&quot;SID &#x3D; &quot;ecology&quot;SYSPASSWORD &#x3D; &quot;192612&quot;SYSTEMPASSWORD &#x3D; &quot;192612&quot;CHARACTERSET &#x3D; &quot;AL32UTF8&quot;INSTANCENAME &#x3D; &quot;ecology&quot;TOTALMEMORY &#x3D; &quot;800&quot;DB_UNIQUE_NAME &#x3D; &quot;ecology&quot; 执行静默建库 12su - oracledbca -silent -responseFile &#x2F;data&#x2F;etc&#x2F;dbca.rsp 执行过程如下 123456789101112131415161718192021222324[oracle@xiaofeifei database]$ dbca -silent -responseFile &#x2F;data&#x2F;etc&#x2F;dbca.rspCopying database files 1% complete 3% complete 11% complete 18% complete 26% complete 37% complete Creating and starting Oracle instance 40% complete 45% complete 50% complete55% complete56% complete60% complete62% completeCompleting Database Creation66% complete70% complete73% complete85% complete96% complete100% completeLook at the log file &quot;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;cfgtoollogs&#x2F;dbca&#x2F;ecology&#x2F;ecology.log&quot; for further details. 查看进程 1ps -ef | grep ora_ | grep -v grep 查看监听状态 1lsnrctl status 16. 静默创建数据库部分参数说明123456789101112131415RESPONSEFILE_VERSION &#x3D; &quot;11.2.0&quot; #不能更改 OPERATION_TYPE &#x3D; &quot;createDatabase&quot; #不变 默认即可 GDBNAME &#x3D; &quot;orcl&quot; #数据库的名字，随便怎么改，不影响，自定义 比如&quot;oracle11g.com&quot; SID &#x3D; &quot;orcl&quot; #对应的实例名字instance_name，随便怎么改，不影响，自定义 比如&quot;oracle11g.com&quot; TEMPLATENAME &#x3D; &quot;General_Purpose.dbc&quot; #不变 默认即可 建库用的模板文件 SYSPASSWORD &#x3D; &quot;oracle&quot; #SYS管理员密码 自定义 SYSTEMPASSWORD &#x3D; &quot;oracle&quot; #SYSTEM管理员密码 自定义 DATAFILEDESTINATION &#x3D; &#x2F;data&#x2F;app&#x2F;oracle&#x2F;oradata #数据文件存放目录 可自定义如&#x2F;data目录但用户和组要是oracle:oinstall即mkdir &#x2F;data ; chown -R oracle:oinstall &#x2F;data ; chmod -R 775 &#x2F;data; 当然此项默认是$ORACLE_BASE&#x2F;oradata 此项本来是注释掉的，而$ORACLE_BASE&#x2F;oradata就是&#x2F;data&#x2F;app&#x2F;oracle&#x2F;oradata，故此项可不用动，即保持注释掉即也可； RECOVERYAREADESTINATION&#x3D;&#x2F;data&#x2F;app&#x2F;oracle&#x2F;flash_recovery_area #恢复数据存放目录 闪回区 可自定义 CHARACTERSET &#x3D; &quot;AL32UTF8&quot; #字符集，重要!!! 建库后一般不能更改，所以建库前要确定清楚，选AL32UTF8比较合适； NATIONALCHARACTERSET&#x3D; &quot;AL16UTF16&quot; #最好还是保持默认的&quot;AL16UTF16&quot;，这里我选的UTF8可能出现了后面的PLSQL中文乱码； #MEMORYPERCENTAGE &#x3D; &quot;40&quot; #服务器物理内存分配给oracle的内存比例，这里先不选 #TOTALMEMORY &#x3D; &quot;3500&quot; # &#x2F;&#x2F;物理内存的60%左右，分配给oracle的总内存3500MB，可自行设定 或者注释不选因为oracle会自行管理； #-----------------------*** End of CREATEDATABASE section ***------------------------ SOURCEDB &#x3D; &quot;myhost:1521:orcl&quot; #End of CREATEDATABASE sectio后面的很多没有注释掉的选项不用管。 17. 至此数据库就安装成功了，下面我们登陆下数据库123su - oraclesqlplus &#x2F; as sysdbaselect status from v$instance; 执行select时，会出现以下情况 1234567SQL&gt; select status from v$instance;select status from v$instance*ERROR at line 1:ORA-01034: ORACLE not availableProcess ID: 0Session ID: 0 Serial number: 0 解决方式：输入startup 1234567#startup的输出提示：SQL&gt; statupSP2-0042: unknown command &quot;statup&quot; - rest of line ignored.SQL&gt; startup#如果是在&#x2F;u01的路径下则不会出现以下问题#ORA-01078: failure in processing system parameters#LRM-00109: could not open parameter file &#39;&#x2F;data&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbs&#x2F;initORCL.ora&#39; 激活scott用户： 123alter user scott account unlock;alter user scott identified by tiger;select username,account_status from dba_users; 18. 设置Oracle开机启动这个步骤还未进行操作…. 19. 结合业务系统配置ecology数据库 创建Ecology数据库用户前的检查工作，首选需要确认监听是否正常 切换到oracle用户下:su - oracle 启动监听：lsnrctl start 查看监听状态:lsnrctl status 1234567891011121314151617181920212223[oracle@xiaofeifei database]$ lsnrctl statusLSNRCTL for Linux: Version 11.2.0.1.0 - Production on 23-AUG-2020 16:49:31 Copyright (c) 1991, 2009, Oracle. All rights reserved. Connecting to (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;IPC)(KEY&#x3D;EXTPROC1521)))STATUS of the LISTENERAlias LISTENERVersion TNSLSNR for Linux: Version 11.2.0.1.0 - ProductionStart Date 23-AUG-2020 11:02:27Uptime 0 days 5 hr. 47 min. 4 secTrace Level offSecurity ON: Local OS AuthenticationSNMP OFFListener Parameter File &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;network&#x2F;admin&#x2F;listener.oraListener Log File &#x2F;u01&#x2F;app&#x2F;oracle&#x2F;diag&#x2F;tnslsnr&#x2F;xiaofeifei&#x2F;listener&#x2F;alert&#x2F;log.xmlListening Endpoints Summary... (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;ipc)(KEY&#x3D;EXTPROC1521))) (DESCRIPTION&#x3D;(ADDRESS&#x3D;(PROTOCOL&#x3D;tcp)(HOST&#x3D;xiaofeifei)(PORT&#x3D;1521)))Services Summary...Service &quot;ecology&quot; has 1 instance(s). Instance &quot;ecology&quot;, status READY, has 1 handler(s) for this service...Service &quot;ecologyXDB&quot; has 1 instance(s). Instance &quot;ecology&quot;, status READY, has 1 handler(s) for this service...The command completed successfully 使用sysdba登录后，查看数据库状态(READ WRITE 为正常读写状态) 命令:select open_mode from v$database; 123SQL&gt; select open_mode from v$database;OPEN_MODEREAD WRITE 查看数据库数据文件存放目录。命令为:select name from v$datafile; 123456789SQL&gt; select name from v$datafile;NAME&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;system01.dbf&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;sysaux01.dbf&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;undotbs01.dbf&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;users01.dbf&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;ecology.dbf 创建OA数据库使用用户和表空间，并赋予用户权限 创建OA 程序使用的表空间，表空间名为ECOLOGY，存储路径为/u01/app/oracle/oradata/ecology/ecology.dbf(此处存储路径是根据上面查询数据库数据文件存放目录确定的)。相关命令 123create tablespace ecology datafile &#39;&#x2F;u01&#x2F;app&#x2F;oracle&#x2F;oradata&#x2F;ecology&#x2F;ecology.dbf&#39; size 2000MAutoExtend On Next 10Msegment space management auto; 创建用户，并关联用户使用的表空间和临时表空间，相关命令 1CREATE USER ecology IDENTIFIED BY ecology DEFAULT TABLESPACE ecology TEMPORARY TABLESPACE Temp; 赋予OA 数据库用户权限（金融等行业客户无法给予DBA 权限),相关命令为： 1234grant connect,resource to ecology;alter user ecology quota unlimited on ecology;grant create view to ecology;grant DATAPUMP_EXP_FULL_DATABASE ,DATAPUMP_IMP_FULL_DATABASE to ecology; 需要使用sysdba 用户执行，避免初始化时出现报错。相关命令为 1alter system set &quot;_allow_level_without_connect_by&quot; &#x3D; true; (对于上述第三步操作说明)需要修改此参数主要是因为我们脚本中有些递归查询和上下级的查询使用了level 关键字，此语法在Oracle9i 版本中默认兼容支持，在10g 及之后的版本中需要修改上面的参数之后才能支持。","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://lwblog.xyz/tags/oracle/"}]},{"title":"MySQL学习笔记二","slug":"MySQL学习笔记二","date":"2020-08-17T01:04:45.000Z","updated":"2020-08-17T01:07:00.875Z","comments":true,"path":"posts/671486fb.html","link":"","permalink":"http://lwblog.xyz/posts/671486fb.html","excerpt":"","text":"MySQL学习笔记二1.分组查询1.1 添加分组签筛选作为条件的字段都来自于原始表单，可以将筛选条件放在where子句的后边 1.2 添加分组后筛选案例：查询那个部门的员工个数&gt;2作为条件的字段不是来自于原始的表单，需要使用having的关键字来筛选,需要放在group by关键字后边 1.3 函数分组group by子句后边还支持按照表达式或者函数进行分组案例：按照员工姓名长度分组，查询每一组员工的个数，筛选员工个数&gt;5的有哪些 1.4 按多个字段分组案例：每个部门，每个工种的员工的平均工资 1.5 添加排序分组查询也可以支持排序 2. 连接查询查询的字段来自于多个表单，需要用到连接查询 2.1 笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n行避免：添加有效的连接条件 2.2 连接查询分类按照年代分类：sql92标准、sql99标准按照功能分类：内连接、外连接、交叉连接 2.3 等值连接介绍如果给表起了别名，就不能用原来的表名称去限定字段的特点： 多表等值连接的结果为多表的交集部分 n表连接，至少需要n-1个连接条件 多表连接的顺序没有要求 一般需要为表起别名 可以搭配前面介绍的所有的字句使用案例：查询女神和对应男神的名称 1select beauty.&#96;name&#96;,boys.boyNamefrom boys,beauty where beauty.boyfriend_id &#x3D; boys.id 2.4 非等值连接案例：查询员工工资和工资级别 1234SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;AND g.&#96;grade_level&#96;&#x3D;&#39;A&#39;; 2.5 自连接自己连接自己案例：查询员工名称和上级员工名称 123SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.&#96;manager_id&#96;&#x3D;m.&#96;employee_id&#96;; 3. sql99语法3.1 语法介绍1999年新推出的sql标准语法 1234567select 查询列表from 表1 【连接类型】join 表2 别名 on 连接条件【where 筛选条件】【group by 分组】【having 筛选条件】【order by 排序列表】 3.2 等值连接表的位置是可以进行互换的语法： 123select 查询列表from 表1 别名inner join 表2 别名 on 连接条件 案例1:查询员工名称和部门名称 1234select last_name,department_namefrom employees einner join departments don e.department_id &#x3D; d.department_id 案例2:查询员工名、部门名、工种名，并按部门名降序(三表连接) 123456-- 连接的表需要和前边有联系(有一定的联系)SELECT last_name,department_name,job_titleFROM employees eINNER JOIN departments d ON e.&#96;department_id&#96;&#x3D;d.&#96;department_id&#96;INNER JOIN jobs j ON e.&#96;job_id&#96; &#x3D; j.&#96;job_id&#96;ORDER BY department_name DESC; 3.3 非等值连接案例1:查询员工的工资级别 1234SELECT salary,grade_levelFROM employees e JOIN job_grades g ON e.&#96;salary&#96; BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96;; 案例2:查询工资级别的个数&gt;20的个数，并且按工资级别降序 123456SELECT COUNT(*),grade_levelFROM employees e JOIN job_grades g ON e.&#96;salary&#96; BETWEEN g.&#96;lowest_sal&#96; AND g.&#96;highest_sal&#96; GROUP BY grade_level HAVING COUNT(*)&gt;20 3.4 自连接案例1:查询员工的名字、上级的名字 1234SELECT e.last_name,m.last_name FROM employees e JOIN employees m ON e.&#96;manager_id&#96;&#x3D; m.&#96;employee_id&#96;; 案例2:查询姓名中包含字符k的员工的名字、上级的名字 12345SELECT e.last_name,m.last_nameFROM employees eJOIN employees mON e.&#96;manager_id&#96;&#x3D; m.&#96;employee_id&#96;WHERE e.&#96;last_name&#96; LIKE &#39;%k%&#39;; 3.5 左(右)外连接应用场景:用于查询一个表中有，另一个表没有的记录特点： 外连接的查询结果为主表中的所有记录 如果从表中有和它匹配的，则显示匹配的值 如果从表中没有和它匹配的，则显示null 外连接查询结果=内连接结果+主表中有而从表没有的记录 左外连接，left join左边的是主表 右外连接，right join右边的是主表 左外和右外交换两个表的顺序，可以实现同样的效果 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的 案例1:查询哪个部门没有员工左外： 12345SELECT d.*,e.employee_id FROM departments d LEFT OUTER JOIN employees e ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96; WHERE e.&#96;employee_id&#96; IS NULL; 右外： 12345SELECT d.*,e.employee_id FROM employees e RIGHT OUTER JOIN departments d ON d.&#96;department_id&#96; &#x3D; e.&#96;department_id&#96; WHERE e.&#96;employee_id&#96; IS NULL; 3.6 全外连接==mysql数据库不支持全外连接查询== 12345USE girls; SELECT b.*,bo.* FROM beauty b FULL OUTER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.id; 3.7 交叉连接代表笛卡尔乘积 123SELECT b.*,bo.* FROM beauty b CROSS JOIN boys bo; 4. 子查询介绍含义：出现在其他语句中的select语句，称为子查询或内查询 外部的查询语句，称为主查询或外查询分类： 按子查询出现的位置： 12345678910111213select后面： 仅仅支持标量子查询 from后面： 支持表子查询 where或having后面：★ 标量子查询（单行） √ 列子查询 （多行） √ 行子查询 exists后面（相关子查询） 表子查询 按结果集的行列数不同： 1234标量子查询（结果集只有一行一列）列子查询（结果集只有一列多行）行子查询（结果集有一行多列）表子查询（结果集一般为多行多列） 4.1 where后面标量子查询位置是在where或者having的后面1、标量子查询（单行子查询）2、列子查询（多行子查询）3、行子查询（多列多行）特点:①子查询放在小括号内②子查询一般放在条件的右侧③标量子查询，一般搭配着单行操作符使用:&gt; &lt; &gt;= &lt;= = &lt;&gt;列子查询，一般搭配着多行操作符使用:in、any/some、all④子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果 案例1:查询员工的信息，满足 salary&gt;①结果（标量子查询） 123456789SELECT *FROM employeesWHERE salary&gt;( SELECT salary FROM employees WHERE last_name &#x3D; &#39;Abel&#39;); 案例2:返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资 123456789101112SELECT last_name,job_id,salaryFROM employeesWHERE job_id &#x3D; ( SELECT job_id FROM employees WHERE employee_id &#x3D; 141) AND salary&gt;( SELECT salary FROM employees WHERE employee_id &#x3D; 143); 案例3:查询最低工资大于50号部门最低工资的部门id和其最低工资 1234567SELECT MIN(salary),department_idFROM employeesGROUP BY department_idHAVING MIN(salary)&gt;( SELECT MIN(salary) FROM employees WHERE department_id &#x3D; 50 4.2 where后面的列子查询案例1:返回location_id是1400或1700的部门中的所有员工姓名 1234567SELECT last_nameFROM employeesWHERE department_id &lt;&gt;ALL( SELECT DISTINCT department_id FROM departments WHERE location_id IN(1400,1700)); 案例2:返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary 123456789101112131415161718SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ANY( SELECT DISTINCT salary FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;;#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;( SELECT MAX(salary) FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;; 案例3:返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工 的员工号、姓名、job_id 以及salary 12345678910111213141516171819SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;ALL( SELECT DISTINCT salary FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;;#或SELECT last_name,employee_id,job_id,salaryFROM employeesWHERE salary&lt;( SELECT MIN( salary) FROM employees WHERE job_id &#x3D; &#39;IT_PROG&#39;) AND job_id&lt;&gt;&#39;IT_PROG&#39;; 4.3 where后面的行子查询案例：查询员工编号最小并且工资最高的员工信息 123456789101112SELECT *FROM employeesWHERE employee_id&#x3D;( SELECT MIN(employee_id) FROM employees)AND salary&#x3D;( SELECT MAX(salary) FROM employees); 4.4 select后面的子查询==仅仅支持标量子查询==案例：查询每个部门的员工个数 1234567SELECT d.*,( SELECT COUNT(*) FROM employees e WHERE e.department_id &#x3D; d.&#96;department_id&#96; ) 个数 FROM departments d; 案例2：查询员工号=102的部门名 12345678SELECT ( SELECT department_name,e.department_id FROM departments d INNER JOIN employees e ON d.department_id&#x3D;e.department_id WHERE e.employee_id&#x3D;102 ) 部门名; 4.5 from后面的子查询==将子查询结果充当一张表，要求必须起别名==案例：查询每个部门的平均工资的工资等级 12345678SELECT ag_dep.*,g.&#96;grade_level&#96;FROM ( SELECT AVG(salary) ag,department_id FROM employees GROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal; 4.6 exists后面的子查询语法： 12exists(完整的查询语句)结果：1或0 案例1：查询有员工的部门名 123456789101112131415161718#inSELECT department_nameFROM departments dWHERE d.&#96;department_id&#96; IN( SELECT department_id FROM employees)#existsSELECT department_nameFROM departments dWHERE EXISTS( SELECT * FROM employees e WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;); 案例2：查询没有女朋友的男神信息 123456789101112131415161718#inSELECT bo.*FROM boys boWHERE bo.id NOT IN( SELECT boyfriend_id FROM beauty)#existsSELECT bo.*FROM boys boWHERE NOT EXISTS( SELECT boyfriend_id FROM beauty b WHERE bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;); 5. 分页查询应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求语法： 123456789101112select 查询列表 from 表 【join type join 表2 on 连接条件 where 筛选条件 group by 分组字段 having 分组后的筛选 order by 排序的字段】 limit 【offset,】size; offset要显示条目的起始索引（起始索引从0开始） size 要显示的条目个数 特点：①limit语句放在查询语句的最后 ②公式 要显示的页数 page，每页的条目数size select 查询列表 from 表 limit (page-1)*size,size;6.联合查询介绍应用场景：要查询的结果来自多个表，且多个表没有直接的关系，但查询信息节本一样union 联合 合并：将多条查询语句的结果合并成一个结果案例：查询中国用户中男性的信息以及外国用户中年男性的用户信息 123456789-- 去掉重复的SELECT * FROM employees WHERE email LIKE &#39;%a%&#39;UNIONSELECT * FROM employees WHERE department_id&gt;90;-- 包含重复项SELECT id,cname FROM t_ca WHERE csex&#x3D;&#39;男&#39;UNION ALLSELECT t_id,tname FROM t_ua WHERE tGender&#x3D;&#39;male&#39;; 7.联合查询特点特点：★1、要求多条查询语句的查询列数是一致的！2、要求多条查询语句的查询的每一列的类型和顺序最好一致3、union关键字默认去重，如果使用union all 可以包含重复项 8. 插入语句8.1 插入语句方式一8.2 插入语句方式二9.修改表单记录9.1 修改单表记录9.2 修改多表记录语法： 1234567891011sql92语法：update 表1 别名,表2 别名set 列 &#x3D; 值where 连接条件 and 筛选条件sql99语法：update 表1 别名inner|left|right join 表2 别名on 连接条件set 列 &#x3D; 值where 筛选条件 10. 删除语句介绍10.1 删除方式一删除表单的整行记录，自增长列的值从断点开始语法： 1delete from 表名 where 筛选条件 10.2 删除方式二删除了整个表单的记录，不能添加where条件，自增长的值从1开始语法： 1truncate table 表名 11. DDL语言介绍创建： create修改： alter删除： drop 11.1 库的管理案例:创建库Books 1CREATE DATABASE IF NOT EXISTS books ; 案例2:库的修改 1RENAME DATABASE books TO 新库名; 案例3:更改库的字符集 1ALTER DATABASE books CHARACTER SET gbk; 案例4:库的删除 1DROP DATABASE IF EXISTS books; 11.2 表的创建语法: 1234567create table 表名( 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, 列名 列的类型【(长度) 约束】, ... 列名 列的类型【(长度) 约束】) 案例：创建表Book 1234567CREATE TABLE book( id INT,#编号 bName VARCHAR(20),#图书名 price DOUBLE,#价格 authorId INT,#作者编号 publishDate DATETIME#出版日期); 案例：创建表author 123456CREATE TABLE IF NOT EXISTS author( id INT, au_name VARCHAR(20), nation VARCHAR(10))DESC author; 11.3 表的修改语法： 1alter table 表名 add|drop|modify|change column 列名 【列类型 约束】; 案例 1234567891011#①修改列名ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;#②修改列的类型或约束ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;#③添加新列ALTER TABLE author ADD COLUMN annual DOUBLE; #④删除列ALTER TABLE book_author DROP COLUMN annual;#⑤修改表名ALTER TABLE author RENAME TO book_author;DESC book; 11.4 表的删除12DROP TABLE IF EXISTS book_author;SHOW TABLES; 11.5 表的复制案例：仅仅复制表的结构 1CREATE TABLE copy LIKE author; 案例：复制表的结构+数据 12CREATE TABLE copy2 SELECT * FROM author; 案例：只复制部分数据 1234CREATE TABLE copy3SELECT id,au_nameFROM author WHERE nation&#x3D;&#39;中国&#39;; 案例：仅仅复制某些字段 1234CREATE TABLE copy4 SELECT id,au_nameFROM authorWHERE 0; 12. 数据类型介绍常见的数据类型数值型： 整型 小数： 定点数 浮点数字符型： 较短的文本：char、varchar 较长的文本：text、blob（较长的二进制数据） 日期型： 12.1 整型分类：tinyint、smallint、mediumint、int/integer、bigint 1 2 3 4 8 特点：① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值③ 如果不设置长度，会有默认的长度长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！ 12.2 浮点型分类：1.浮点型float(M,D)double(M,D)2.定点型dec(M，D)decimal(M,D)特点：①M：整数部位+小数部位 D：小数部位 如果超过范围，则插入临界值②M和D都可以省略，如果是decimal，则M默认为10，D默认为0，如果是float和double，则会根据插入的数值的精度来决定精度③定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用 12.3 字符型较短的文本：char、varchar其他：binary和varbinary用于保存较短的二进制enum用于保存枚举set用于保存集合较长的文本：text、blob(较大的二进制) 12.4 日期型分类：date只保存日期time 只保存时间year只保存年datetime保存日期+时间timestamp保存日期+时间 13. 常见约束介绍not null:非空约束，用于保证该字段的值不能为空DEFAULT：默认约束,用于保证该字段有默认值PRIMARY KEY：主键约束，保证该字段的值具有唯一性，并且非空UNIQUE：唯一约束，用于保证该字段的值具有唯一性，可以为空CHECK：检查约束【mysql中不支持】FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值在从表添加外键约束，用于引用主表中某列的值 13.1 创建表时添加列级约束直接在字段名和类型后面追加 约束类型即可。只支持：默认、非空、主键、唯一 12345678910USE students;DROP TABLE stuinfo;CREATE TABLE stuinfo( id INT PRIMARY KEY,#主键 stuName VARCHAR(20) NOT NULL UNIQUE,#非空 gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查 seat INT UNIQUE,#唯一 age INT DEFAULT 18,#默认约束 majorId INT REFERENCES major(id)#外键); 13.2 创建表时添加表级约束语法：在各个字段的最下面 【constraint 约束名】 约束类型(字段名) 12345678910111213141516171819202122232425262728DROP TABLE IF EXISTS stuinfo;CREATE TABLE stuinfo( id INT, stuname VARCHAR(20), gender CHAR(1), seat INT, age INT, majorid INT, CONSTRAINT pk PRIMARY KEY(id),#主键 CONSTRAINT uq UNIQUE(seat),#唯一键 CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender &#x3D; &#39;女&#39;),#检查 CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键 );#通用的写法：★CREATE TABLE IF NOT EXISTS stuinfo( id INT PRIMARY KEY, stuname VARCHAR(20), sex CHAR(1), age INT DEFAULT 18, seat INT UNIQUE, majorid INT, CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)); 13.3 主键和唯一的区别13.4 外键的特点13.5 修改表时添加约束1、添加列级约束alter table 表名 modify column 字段名 字段类型 新约束;2、添加表级约束alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】; 12345678910111213141516#1.添加非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL;#2.添加默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;#3.添加主键#①列级约束ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;#②表级约束ALTER TABLE stuinfo ADD PRIMARY KEY(id);#4.添加唯一#①列级约束ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;#②表级约束ALTER TABLE stuinfo ADD UNIQUE(seat);#5.添加外键ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); 13.6 修改表时去掉约束12345678910#1.删除非空约束ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;#2.删除默认约束ALTER TABLE stuinfo MODIFY COLUMN age INT ;#3.删除主键ALTER TABLE stuinfo DROP PRIMARY KEY;#4.删除唯一ALTER TABLE stuinfo DROP INDEX seat;#5.删除外键ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major; 14. 标识列又称为自增长列含义：可以不用手动的插入值，系统提供默认的序列值 特点：1、标识列必须和主键搭配吗？不一定，但要求是一个key2、一个表可以有几个标识列？至多一个！3、标识列的类型只能是数值型4、标识列可以通过 SET auto_increment_increment=3;设置步长可以通过 手动插入值，设置起始值 15. 事务介绍Transaction Control Language 事务控制语言一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。事务的特性：ACID原子性：一个事务不可再分割，要么都执行要么都不执行一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态隔离性：一个事务的执行不受其他事务的干扰持久性：一个事务一旦提交，则会永久的改变数据库的数据. 事务的创建隐式事务：事务没有明显的开启和结束的标记比如insert、update、delete语句 delete from 表 where id =1; 显式事务：事务具有明显的开启和结束的标记前提：必须先设置自动提交功能为禁用 set autocommit=0; 步骤1：开启事务set autocommit=0;start transaction;可选的步骤2：编写事务中的sql语句(select insert update delete)语句1;语句2;… 步骤3：结束事务commit;提交事务rollback;回滚事务 savepoint 节点名;设置保存点 15.1 事务的隔离 15.2 回滚123456789101112131415161718192021222324252627282930313233#1.演示事务的使用步骤#开启事务SET autocommit&#x3D;0;START TRANSACTION;#编写一组事务的语句UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;#结束事务ROLLBACK;#commit;SELECT * FROM account;#2.演示事务对于delete和truncate的处理的区别SET autocommit&#x3D;0;START TRANSACTION;DELETE FROM account;ROLLBACK;#3.演示savepoint 的使用SET autocommit&#x3D;0;START TRANSACTION;DELETE FROM account WHERE id&#x3D;25;SAVEPOINT a;#设置保存点DELETE FROM account WHERE id&#x3D;28;ROLLBACK TO a;#回滚到保存点 16. 视图介绍含义：虚拟表，和普通的表一样使用 16.1 视图创建语法：create view 视图名as查询语句; 123456CREATE VIEW myv1ASSELECT last_name,department_name,job_titleFROM employees eJOIN departments d ON e.department_id &#x3D; d.department_idJOIN jobs j ON j.job_id &#x3D; e.job_id; 16.2 视图修改方式一：create or replace view 视图名as查询语句; 方式二：语法：alter view 视图名as查询语句; 16.3 视图查看和删除删除视图：语法：drop view 视图名,视图名,…;查看视图：DESC myv3;SHOW CREATE VIEW myv3; 16.4 视图更新123456789CREATE OR REPLACE VIEW myv1ASSELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) &quot;annual salary&quot;FROM employees;CREATE OR REPLACE VIEW myv1ASSELECT last_name,emailFROM employees; 具备以下特点的视图不允许更新：1.含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all2.常量视图3.Select中包含子查询4.join5.from一个不能更新的视图6.where子句的子查询引用了from子句中的表 17. 函数和存储过程说明：变量由系统定义，不是用户定义，属于服务器层面注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别使用步骤：1、查看所有系统变量show global|【session】variables;2、查看满足条件的部分系统变量show global|【session】 variables like ‘%char%’;3、查看指定的系统变量的值select @@global|【session】系统变量名;4、为某个系统变量赋值方式一：set global|【session】系统变量名=值;方式二：set @@global|【session】系统变量名=值; 17.1 全局变量作用域：针对于所有会话（连接）有效，但不能跨重启 123456789#①查看所有全局变量SHOW GLOBAL VARIABLES;#②查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;#③查看指定的系统变量的值SELECT @@global.autocommit;#④为某个系统变量赋值SET @@global.autocommit&#x3D;0;SET GLOBAL autocommit&#x3D;0; 17.2 会话变量作用域：针对于当前会话（连接）有效 12345678910#①查看所有会话变量SHOW SESSION VARIABLES;#②查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;#③查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;#④为某个会话变量赋值SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;; 17.3 自定义变量-用户变量说明：变量由用户自定义，而不是系统提供的使用步骤：1、声明2、赋值3、使用（查看、比较、运算等）作用域：针对于当前会话（连接）有效，作用域同于会话变量 赋值操作符：=或:=①声明并初始化SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值; ②赋值（更新变量的值）方式一： SET @变量名=值; SET @变量名:=值; SELECT @变量名:=值;方式二： SELECT 字段 INTO @变量名 FROM 表;③使用（查看变量的值）SELECT @变量名; 17.4 自定义变量-局部变量作用域：仅仅在定义它的begin end块中有效应用在 begin end中的第一句话 ①声明DECLARE 变量名 类型;DECLARE 变量名 类型 【DEFAULT 值】; ②赋值（更新变量的值）方式一： SET 局部变量名=值; SET 局部变量名:=值; SELECT 局部变量名:=值;方式二： SELECT 字段 INTO 具备变量名 FROM 表;③使用（查看变量的值）SELECT 局部变量名; 案例：声明两个变量，求和并打印 123456789101112#用户变量SET @m&#x3D;1;SET @n&#x3D;1;SET @sum&#x3D;@m+@n;SELECT @sum;#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 1;DECLARE SUM INT;SET SUM&#x3D;m+n;SELECT SUM; 17.5 存储过程介绍含义：一组预先编译好的SQL语句的集合，理解成批处理语句1、提高代码的重用性2、简化操作3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 17.6 存储过程语法 创建语法 1234567891011121314151617181920CREATE PROCEDURE 存储过程名(参数列表)BEGIN 存储过程体（一组合法的SQL语句）END ⚠️ 1.参数列表包含三部分: in stuname varchar(20) 参数模式： in:该参数可以作为输入，也就是该参数需要调用方传入值 out:该参数可以作为输出，也就是该参数可以作为返回值 inout:该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又 可以返回值 参数名： 参数类型： 2.如果存储过程体仅仅只有一句话，begin end可以省略 3.存储过程体中的每条sql语句的结尾要求必须加分号 4.存储过程的结尾可以使用 delimiter 重新设置 语法： delimiter 结束标记 案例： delimiter $ 调用方法 CALL 存储过程名(实参列表); 17.7 空参的存储过程12345678# 定义存储过程delimiter $create PROCEDURE myp2()begin insert into admin(username,&#96;password&#96;) values(&#39;测试&#39;,&#39;12345&#39;);end $call myp2()$ 17.8 带in模式的存储过程案例1：创建存储过程实现 根据女神名，查询对应的男神信息 123456789create PROCEDURE myp3(in beatyName VARCHAR(20))begin select be.*,bo.* from beauty be left join boys bo on be.boyfriend_id &#x3D; bo.id where be.name &#x3D; beatyName;endcall myp3(&#39;柳岩&#39;) 案例2 ：创建存储过程实现，用户是否登录成功 123456789101112create PROCEDURE myp4(in username VARCHAR(20),in password VARCHAR(20))begin DECLARE result VARCHAR(20) DEFAULT &#39;&#39;; # 声明并初始化 select count(*) into result # 赋值 from admin where admin.username &#x3D; username and admin.password &#x3D; password; select result; # 使用endcall myp4(&#39;ceshi&#39;,&#39;123&#39;) 17.9 带out模式的存储过程案例1：根据输入的女神名，返回对应的男神名 123456789CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))BEGIN SELECT bo.boyname INTO boyname FROM boys bo RIGHT JOIN beauty b ON b.boyfriend_id &#x3D; bo.id WHERE b.name&#x3D;beautyName ; END $ 案例2：根据输入的女神名，返回对应的男神名和魅力值 1234567891011create PROCEDURE myp8(in beatyName varchar(20),out boyName varchar(20),out usercp int)BEGIN select bo.boyName ,bo.userCP into boyName ,usercp from boys bo inner join beauty b on bo.id &#x3D; b.boyfriend_id where b.name &#x3D; beatyName;ENDcall myp8(&#39;小昭&#39;,@bName,@cp)select @bName,@cp 17.10 带inout模式的存储过程案例1：传入a和b两个值，最终a和b都翻倍并返回 12345678910create PROCEDURE myp9(inout a int,inout b int)BEGIN set a &#x3D; a * 2; set b &#x3D;b * 2;END# 调用set @n&#x3D;8;set @m&#x3D;10;call myp9(@n,@m);select @m,@n 17.11 存储过程的删除12语法：drop procedure 存储过程名DROP PROCEDURE p1; 17.12 存储过程查看12查看存储过程的信息SHOW CREATE PROCEDURE myp2; 18. 函数的介绍含义：一组预先编译好的SQL语句的集合，理解成批处理语句1、提高代码的重用性2、简化操作3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率 区别： 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新函数：有且仅有1 个返回，适合做处理数据后返回一个结果 18.1 函数的创建和调用语法 创建语法 1234567891011CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN 函数体END⚠️1.参数列表包括两部分：参数名和参数类型2.函数体：肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议3.函数体中仅有一句话，则可以省略begin end4.使用 delimiter语句设置结束标记 调用语法：SELECT 函数名(参数列表) 案例 无参有返回 123456789 #案例：返回公司的员工个数 create function myf1() returns intBEGINDECLARE c int default 0;# 定义变量 select count(*) into c# 为变量赋值 from employees; return c;ENDselect myf1(); 有参有返回 12345678 #案例1：根据员工名，返回它的工资 create function myf2(empName varchar(20)) returns doubleBEGIN set @sal&#x3D;0; # 定义了一个用户变量 select salary into @sal from employees where last_name &#x3D; empName; return @sal;ENDselect myf2(&#39;John&#39;); 18.2 函数的查看和删除SHOW CREATE FUNCTION myf3;DROP FUNCTION myf3; 19. 流程控制结构介绍顺序结构：程序从上往下依次执行分支结构：程序从两条或多条路径中选择一条去执行循环结构：程序在满足一定条件的基础上,重复执行一段代码 19.1 分支结构—if函数语法：if(条件,值1，值2)功能：实现双分支应用在begin end中或外面执行顺序：如果表达式的条件成立，则if返回值1，否则返回值2 19.2 分支结构—case结构语法： 123456789101112131415情况1：类似于switch语句，一般用于实现等值判断case 变量或表达式when 值1 then 语句1;when 值2 then 语句2;...else 语句n;end 情况2：类似于多重if语句，一般用于实现区间判断case when 条件1 then 语句1;when 条件2 then 语句2;...else 语句n;end 特点：应用在begin end 中或外面 可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或外面 可以作为独立的语句去使用，只能放在begin end中 如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case 如果都不满足则执行else中的语句或值 else可以省略，如果else省略了，并且所有where条件都不满足，则返回null 案例: 123456789101112#案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回Dcreate PROCEDURE test_case(in score int)BEGIN case when score &gt;&#x3D; 90 then SELECT &#39;A&#39;; when score &gt;&#x3D;80 then select &#39;B&#39;; when score &gt;&#x3D;70 then select &#39;C&#39;; else select &#39;D&#39;; end case;ENDcall test_case(75) 19.3 分支结构—if结构语法： 123456789语法：if 条件1 then 语句1;elseif 条件2 then 语句2;....else 语句n;end if;功能：类似于多重if只能应用在begin end 中 19.4循环结构的介绍分类： while: loop: repeat: 循环控制： iterate类似于 continue，继续，结束本次循环，继续下一次 leave 类似于 break，跳出，结束当前所在的循环 语法： while 1234567 【标签:】while 循环条件 do 循环体;end while【标签】;联想：while(循环条件)&#123; 循环体;&#125; loop 1234标签:】loop 循环体;end loop 【标签】;# 可以用来模拟简单的死循环 repeat 1234【标签：】repeat 循环体;until 结束循环的条件end repeat 【标签】; 19.5 循环结构演示案例：批量插入，根据次数插入到admin表中多条记录 12345678910create PROCEDURE pro_while1(in insertcount int)BEGIN DECLARE i int DEFAULT 1; while i &lt;&#x3D; insertcount do insert into admin(username,password) values(CONCAT(&#39;ceshi&#39;,i),&#39;6666&#39;); set i &#x3D; i + 1; END WHILE;ENDcall pro_while1(10); 案例2:批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止（添加leave语句） 123456789101112create PROCEDURE pro_while2(in insertcount int)BEGIN DECLARE i int DEFAULT 1; a:while i &lt;&#x3D; insertcount do insert into admin(username,password) values(CONCAT(&#39;xiaohua&#39;,i),&#39;6666&#39;); if i&gt;&#x3D;20 then leave a; end if; set i &#x3D; i + 1; END WHILE a;ENDcall pro_while2(30); 案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次（添加iterate语句） 123456789101112131415TRUNCATE TABLE admin$DROP PROCEDURE test_while1$CREATE PROCEDURE test_while1(IN insertCount INT)BEGIN DECLARE i INT DEFAULT 0; a:WHILE i&lt;&#x3D;insertCount DO SET i&#x3D;i+1; IF MOD(i,2)!&#x3D;0 THEN ITERATE a; END IF; INSERT INTO admin(username,&#96;password&#96;) VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;); END WHILE a;END $CALL test_while1(100)$","categories":[],"tags":[]},{"title":"MySQL高级部分学习一","slug":"MySQL高级部分学习一","date":"2020-08-17T01:04:14.000Z","updated":"2020-08-17T01:07:00.873Z","comments":true,"path":"posts/f2612c14.html","link":"","permalink":"http://lwblog.xyz/posts/f2612c14.html","excerpt":"","text":"MySQL高级部分学习一1. mysql的架构介绍1.1 mysql简介1.2 mysqlLinux版的安装 检查当前系统是否安装过mysql：rpm -qa|grep -i mysql 查看mysql安装时创建的mysql用户和mysql用户组：cat /etc/password|grep mysql、cat /etc/group|grep mysql mysql服务的启动和停止：service mysql start,查看是否启动成功:ps -ef|grep mysql root密码设置和设置开机随机启动:chkconfig mysql on mysql的安装位置：/var/lib/mysql 1.3 MySQL的配置文件:my.cnf1. client:客户端的配置 1.4 Mysql逻辑架构介绍1.5 mysql存储引擎 查看mysql提供的存储引擎:show engines; 查看mysql抢天默认的存储引擎:show variables like &#39;%storage_engine%&#39;; 2. 索引优化分析2.1 SQL性能下降原因 索引失效 关联查询太多join(设计缺陷或不得已的需求) 服务器调优及各个参数设置(缓冲、线程数等) 2.2 SQL执行加载顺序from–on–join–where–group by–having–select–distinct–order by –limit 2.3 七种JOIN理论 2.4 七种JOIN的SQL编写2.5 索引是什么索引(index)是帮助mysql高效获取数据的数据结构。可以理解为“排好顺序快速查找数据结构” 2.6 索引优势劣势优势： 提高检索效率，降低数据库的IO成本 通过索引对数据进行排序，降低数据排序的成本，降低了COU的小号 劣势： 实际上索引也是一张表，该表保存了主键与索引字段，并且指向实体表记录，所以索引也是要占用空间的 虽然索引大大提高了查询速度，但是却会降低更新表的速度 都会调整因为更新所带来的键值变化后的索引信息 2.7 索引分类和建索引命令语句分类 单值索引：即一个索引只包含单个列，一个表可以有多个单列索引 唯一索引：索引列的值唯一，但允许有空值 复合索引：即一个索引包含多个列 语法 创建create [unique] index indexname on mytable(columnname(length))``alter mytable add [unique] index [indexname] on (columnname(length)) 删除：drop index [indexname] on mytable 查看：show index from table_name\\G 2.8 索引结构与检索原理BTree索引、Hash索引、full-text全文索引、R-Tree索引 2.9 哪些情况适合建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外键关系建立索引 频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录还会更新索引 where条件里用不到的字段不创建索引 单键/组合索引的选择问题，who(在高并发下倾向创建组合索引) 查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度 查询中统计或者分组的字段 2.10 哪些情况不适合建索引 表记录太少 经常增删改的表 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。⚠️如果某个数据列包含许多重复内容，为他建立索引就没有太大的实际效果 2.11 性能分析2.11.1 性能分析前提知识MySQL常见瓶颈： CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候 服务器硬件的性能瓶颈，top,free,iostat和vmstat来查看系统的性能状态 2.11.2 explain使用简介使用explain关键字可以模拟优化器执行sql查询语句，从而知道mysql是如何处理sql语句的。分析查询语句或是表结构的性能瓶颈 使用方法：explain + 对应的查询语句 能干啥： 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 2.11.3 explain之ID介绍select查询的序列号，包含一组数字，表示查询中select子句或操作表的顺序三种情况： id相同，执行顺序由上至下 id不相同，如果是子查询，id的序号会递增，id越大优先级越高，越先被执行 id相同和不同同时存在，id越大，越先执行，id相同的，同时执行 2.11.4 explain之select_type和table介绍type:查询的类型，主要用于区别普通查询、联合查询、子查询等复杂的查询 simple:简单的select查询，查询中不包含子查询或者union primary：查询中若包含任何复杂的字部分，最外层查询则被标记为 subquery:在select或where列表中包含了子查询 derived:在from列表中包含的资产讯被标记为derived(衍生)，mysql会递归执行这些子查询，把结果放在临时表 union：若第二个select出现在union之后，则被标记为union，若union包含在from的子句的子查询中，外层select将被标记为derived union result:从union表中select获取的结果 table:是表示这一行的数据表示哪张表 2.11.5 explain之type介绍显示查询使用了何种类型：从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all system:表只有一行记录等于系统表，这是const类型的特例，平常不会出现，可以忽略不计const:表示通过索引一次就找到了，const用于比较primary key或者是unique索引。因为之匹配一行数据，所以很快如将主键置于where列表中，mysql就能将该查询装换为一个常量eq_ref:唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描ref:非唯一性索引扫描，返回匹配某个值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行。然而，他可能会找到多个复合条件的行，所以它属于查找和扫描的混合体range:只检索给定范围的行，使用一个索引来选定行，key列显示使用了哪个索引。一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引扫描比全表扫描要好。因为它只需要开始与索引的某一个点，而结束于另一点，不用扫描全部索引index:full index sacn。index与all区别为index类型值遍历索引树。通常比all快。index从所有的索引中取值。all:full table scan将遍历全表以找到适合的行 2.11.6 explain之possible_key和key介绍possible_key:显示可能应用在这张表中的索引，一个或者多个。查询涉及到字段上若存在索引，则该索引将被列出。但不一定被查询实际使用key:实际使用的索引。如果没有则显示为null.查询中若使用了覆盖索引。则该索引仅出现在key列表中 2.11.7 explain之key_len介绍表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len现实的值为索引字段的最大可能长度，并非实际使用长度，即key_len是分局表定义计算而得。不是通过表内检索出的 2.11.8 explain之ref介绍显示索引哪一列被使用了。如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值 2.11.9 explain之rows介绍根据表统计信息及索引选用情况。大致估算出找到所需的记录所需要读取的行数 2.11.10 explain之extra介绍包含不在其他列展示，但是又十分重要的额外信息 using filesort:说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” using temporary:使用临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by using index:表示相应的select操作中使用了覆盖索引(Covering index),避免访问了表的数据行，效率不错！如果同时出现using where ，表明索引被用来执行索引键值的查找。如果没有同时出现 using where ，表明索引用来读取数据而非执行查找动作。 using where：表明使用了where过滤 using join buffer impossible where:where子句的值总是false,不能用来获取任何元组 select tables optimized away distinct: 2.12 索引优化 全值匹配我最爱 最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中列 不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描 存储引擎不能使用索引中范围条件右边的列(范围之后的索引全都失效) 尽量使用覆盖索引(只访问索引的查询(索引和查询列一致))，减少select * mysql在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引或导致全表扫描 is null,is not null 也无法使用索引 like以通配符开头，mysql索引失效会变成全表扫描的操作 字符串不加单引号索引失效 少用or,用它来连接时会索引失效 3.查询截取分析3.1 查询优化3.1.1 小表驱动大表小表驱动大表，即小的数据集驱动大的数据集当B表的数据集必须小于A表的数据集时，用in优于exists当A表数据集小于B表的数据集时，用exist优于in 3.1.2 in和exists3.1.3 使用索引orderby优化 order by子句，尽量使用index方式排序，避免使用filesort的方式排序 尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀 如果不在索引列上 filesort有两种算法 3.1.4 group by优化基本上和order by的情况相同 3.2 慢查询日志默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定性能影响。慢查询日志支持将日志记录写入文件 查看是否开启及如何开启 默认：show variables like &#39;%slow_query_log%&#39; 开启：set global slow_query_log = 1，只对当前数据库生效，mysql重启后失效 开启后什么样的sql会写入 设置慢的阙值时间：set global long_query_time = 3; 看不到改变的原因:需要重新连接或者新开一个会话才能看到修改值。 show variables like &#39;long_query_time%&#39;、show global variables like &#39;long_query_time&#39; 记录慢SQL后并后续分析 日志分析工具mysqldunpslow 3.3 批量数据脚本 3.4 show Profile是什么：是mysql提供剋月用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量默认情况下，参数处于关闭状态，并保存最近15次的运行结果。分析步骤： 是否支持，看看当前的mysql版本是否支持 开启功能，默认是关闭的，使用前需要开启 运行sql 查看结果，show profiles 诊断SQL：show profile cpu,block io for query 上一步前面问题sql数字号码 日常开发需要注意的结论 converting heap to myisam 查询结果太大，内存都不够用了，往磁盘上办了 creating tmp table 创建临时表(拷贝数据到临时表，用完在删除) copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！ locked3.5 全局查询日志 配置启用 编码启用 永远不要在生产环境中启用 4. MySQL锁机制4.1 数据库锁理论概述 锁的分类：从对数据操作的类型(读/写)分读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响行锁(排他锁)：当前写操作没有完成前，他会阻断其他写锁和读锁从对数据操作的粒度分：表锁/行锁 4.2 读锁案例讲解 4.3 行锁理论 4.4 索引失效行锁变表锁4.5 间隙锁危害 4.6 如何锁定一行4.7 行锁总结 5. 主从复制 复制的基本原理 slave会从master读取binlog来进行数据同步 三个步骤： 复制的基本原则 每个slave只有一个master 复制的最大问题 延时 主从常见配置","categories":[],"tags":[]},{"title":"MySQL数据库学习笔记.md","slug":"MySQL数据库学习笔记-md","date":"2020-08-17T01:03:37.000Z","updated":"2020-08-17T01:07:00.874Z","comments":true,"path":"posts/8d9f420d.html","link":"","permalink":"http://lwblog.xyz/posts/8d9f420d.html","excerpt":"","text":"MySQL数据库学习笔记1.MySQL的语法规范 不区分大小写,但建议关键字大写，表名、列名小写 每条命令最好用分号结尾 每条命令根据需要，可以进行缩进 或换行 注释 单行注释：#注释文字 单行注释：– 注释文字 多行注释：/* 注释文字 */2.SQL的语言分类 DQL（Data Query Language）：数据查询语言 select DML(Data Manipulate Language):数据操作语言:insert、update、delete DDL（Data Define Languge）：数据定义语言:create alter drop TCL（Transaction Control Language）：事务控制语言 commit rollback 3.SQL的常见命令4.DQL语言的学习更加具体的讲解详见对应的尚硅谷查询语句的pdf 进阶1：基础查询语法：select 查询的东西 [from 表名]特点： 1. 通过select查询完的结果 ，是一个虚拟的表格，不是真实存在 2. 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数 进阶2：条件查询条件查询：根据条件过滤原始表的数据，查询到想要的数据语法： select 要查询的字段｜表达式｜常量值｜函数 from 表名 where 条件;分类： 1. 条件表达式 * &gt; * &lt; * &gt;= * &gt;= * = * != * &lt;&gt;:建议使用，不建议使用！= 2. 逻辑表达式：用于连接条件表达式 * and(&amp;&amp;):两个条件如果同时成立,结果为true,否则为false * or(||)：两个条件只要有一个成立，结果为true，否则为false * not(!)：如果条件成立，则not后为false，否则为true 3. 模糊查询 * like * between and * in * is null 进阶3：排序查询详细笔记请见尚硅谷基础学习笔记3 进阶4：常见函数一、单行函数 1、字符函数 concat拼接 substr截取子串 upper转换成大写 lower转换成小写 trim去前后指定的空格和字符 ltrim去左边空格 rtrim去右边空格 replace替换 lpad左填充 rpad右填充 instr返回子串第一次出现的索引 length 获取字节个数 2、数学函数 round 四舍五入 rand 随机数 floor向下取整 ceil向上取整 mod取余 truncate截断3、日期函数 now当前系统日期+时间 curdate当前系统日期 curtime当前系统时间 str_to_date 将字符转换成日期 date_format将日期转换成字符4、流程控制函数 if 处理双分支 case语句 处理多分支 情况1：处理等值判断 情况2：处理条件判断5、其他函数 version版本 database当前库 user当前连接用户","categories":[],"tags":[]},{"title":"StartUML使用技巧.md","slug":"StartUML使用技巧-md","date":"2020-08-13T01:36:12.000Z","updated":"2020-08-13T01:37:41.416Z","comments":true,"path":"posts/80aa353a.html","link":"","permalink":"http://lwblog.xyz/posts/80aa353a.html","excerpt":"","text":"StartUML使用技巧1. 工作界面简单介绍 2.类组件的基本操作介绍单击选择Class，至工作区域内单机左键，即可创建一个class实例。创建实例后，周围会出现一堆，功能按钮，去描述这个类功能介绍： 用来标识Class的可见性 用来添加note的，比如：类的说明 增加类的属性 增加类的操作方法 增加Reception 增加子类 增加父类 添加已有的接口 添加需要的接口 添加关联 添加聚合 添加组合 添加端口 添加部件 3. 类与类之间的关系 聚合关系(Aggregation)：表示一个整体与部分的关系。在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，成员对象可以脱离整体对象独立存在。 在 UML 中，聚合关系用带空心菱形的直线表示。 组合关系(Composition)：组合关系也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。 在UML中，组合关系用带实心菱形的直线表示。 依赖关系(Dependency)：依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。 泛化关系(Generalization)：也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在 UML 中，泛化关系用带空心三角形的直线来表示。 实现关系：实现关系(Realization)是类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。 关联关系(Association)：类与类之间最常用的一种关系，它是一种结构化关系，用于表示一个类对象与另一个类对象之间有联系。在 UML 类图中，用实线连接有关联的对象所对应的类。在实现关联关系时，通常将一个类的对象作为另一个类的属性。 单向关联：类的关联关系可以是单向的，单向关联用带箭头的实线表示。Ctril + L 弄直 双向关联：默认情况下，关联是双向的 自关联：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。 重数性关联：重数性关联关系又称为多重性关联关系(Multiplicity)，表示一个类的对象与另一个类的对象连接的个数。在 UML 中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数 4. UML方法的返回值Operation的返回值：StarUML添加一个Operation，要Add一个Parameter，将这个Parameter的DirectionKind设为RETURN。","categories":[],"tags":[]},{"title":"Mybatis学习笔记二","slug":"Mybatis学习笔记二","date":"2020-06-10T13:17:53.000Z","updated":"2020-06-10T13:18:55.544Z","comments":true,"path":"posts/a71dc8d.html","link":"","permalink":"http://lwblog.xyz/posts/a71dc8d.html","excerpt":"","text":"1. Mybatis逆向工程1.1 说明 MyBatis Generator官方文档地址 官方工程地址 依赖的包 1234567891011&lt;!--mybatis逆向工程依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 1.2 逆向功能的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime&#x3D;&quot;MyBatis3Simple&quot;:生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id&#x3D;&quot;DB2Tables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?allowMultiQueries&#x3D;true&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;123456&quot;&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage&#x3D;&quot;test.model&quot;：目标包名 targetProject&#x3D;&quot;\\MBGTestProject\\src&quot;：目标工程 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.atguigu.mybatis.bean&quot; targetProject&#x3D;&quot;.\\src&quot;&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.atguigu.mybatis.dao&quot; targetProject&#x3D;&quot;.\\conf&quot;&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.atguigu.mybatis.dao&quot; targetProject&#x3D;&quot;.\\src&quot;&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName&#x3D;&quot;tbl_dept&quot; domainObjectName&#x3D;&quot;Department&quot;&gt;&lt;&#x2F;table&gt; &lt;table tableName&#x3D;&quot;tbl_employee&quot; domainObjectName&#x3D;&quot;Employee&quot;&gt;&lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; 2. Mybatis的运行原理 2.1 sqlsessionFactory的初始化 根据配置文件创建sqlsessionFactory 几个重要的类 2.2 openSession获取SqlSession对象返回SqlSession的实现类DefaultSqlSession对象。他里面包含了Executor和Configuration；Executor会在这一步被创建 2.3 getMapper获取到接口的代理对象getMapper返回接口的代理对象包含了SqlSession对象 2.4 查询实现 3.插件MyBatis在四大对象的创建过程中，都会有插件进行介入。插件可以利用动态代理机制一层层的包装目标对象，而实现在目标对象执行目标方法之前进行拦截的效果。MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler(getParameterObject, setParameters) ResultSetHandler(handleResultSets, handleOutputParameters) StatementHandler(prepare, parameterize, batch, update, query) 3.1 插件开发的步骤 编写插件实现Interceptor接口并使用@Intercepts注解完成插件签名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.atguigu.in;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.plugin.*;import java.util.Properties;&#x2F;** * intercept:拦截目标对象的目标方法的执行 * 完成插件的签名： * 告诉mybatis当前插件来拦截那个执行器的那个方法 *&#x2F;@Intercepts(&#123; @Signature( type &#x3D; StatementHandler.class,method &#x3D; &quot;parameterize&quot;,args&#x3D;java.sql.Statement.class )&#125;)public class MyFirstIn implements Interceptor &#123; @Override public Object intercept(Invocation invocation) throws Throwable &#123; &#x2F;&#x2F;放行执行目标方法 Object proceed &#x3D; invocation.proceed(); return proceed; &#125; &#x2F;** * 插件包装 * 为目标对象创建一个代理对象 * @param target * @return *&#x2F; @Override public Object plugin(Object target) &#123; Object wrap &#x3D; Plugin.wrap(target, this); &#x2F;&#x2F;我们可以借助Plugin的wrap方法来使用当前的拦截器包装我们的对象 &#x2F;&#x2F;返回为当前target创建的动态代理 return wrap; &#125; &#x2F;** * 将插件注册时的properties属性注册出来 * @param properties *&#x2F; @Override public void setProperties(Properties properties) &#123; System.out.println(&quot;可以拿到插件的信息&quot;); &#125;&#125; 在全局配置文件中注册插件 12345&lt;plugins&gt; &lt;plugin interceptor&#x3D;&quot;com.atguigu.in.MyFirstIn&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ceshi&quot;&#x2F;&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; 4. mybatis批量操作 默认的openSession() 方法没有参数,它会创建有如下特性的 会开启一个事务(也就是不自动提交) 连接对象会从由活动环境配置的数据源实例得到 事务隔离级别将会使用驱动或数据源的默认设置 预处理语句不会被复用,也不会批量处理更 openSession 方法的ExecutorType类型的参数，枚举类型: ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情（这是默认装配的）。它为每个语句的执行创建一个新的预处理语句 ExecutorType.REUSE: 这个执行器类型会复用预处理语句 ExecutorType.BATCH: 这个执行器会批量执行所有更新语句 批量操作我们是使用MyBatis提供的BatchExecutor进行的，他的底层就是通过jdbc攒sql的方式进行的。我们可以让他攒够一定数量后发给数据库一次 12345678910111213 publicvoidtest01() &#123;SqlSession openSession &#x3D; build.openSession(ExecutorType.BATCH);UserDao mapper &#x3D; openSession.getMapper(UserDao.class);longstart &#x3D; System.currentTimeMillis();for(inti &#x3D; 0; i &lt; 1000000; i++) &#123;String name &#x3D; UUID.randomUUID().toString().substring(0, 5);mapper.addUser(newUser(null, name, 13));&#125;openSession.commit();openSession.close();longend &#x3D; System.currentTimeMillis();System.out.println(&quot;耗时时间：&quot;+(end-start));&#125; 与Spring整合中，我们推荐，额外的配置一个可以专门用来执行批量操作的sqlSession 需要用到批量操作的时候，我们可以注入配置的这个批量SqlSession。通过他获取到mapper映射器进行操作 注意 批量操作是在session.commit()以后才发送sql语句给数据库进行执行的 如果我们想让其提前执行，以方便后续可能的查询操作获取数据，我们可以使用sqlSession.flushStatements()方法，让其直接冲刷到数据库进行执行 5. 一个带游标的存储过程 MyBatis对存储过程的游标提供了一个JdbcType=CURSOR的支持，可以智能的把游标读取到的数据，映射到我们声明的结果集中 存储过程的调用 select标签中statementType=“CALLABLE” 标签体中调用语法：{call procedure_name(#{param1_info},#{param2_info})} 6.自定义TypeHandler处理枚举 我们可以通过自定义TypeHandler的形式来在设置参数或者取出结果集的时候自定义参数封装策略 步骤 实现TypeHandler接口或者继承BaseTypeHandler 使用@MappedTypes定义处理的java类型 使用@MappedJdbcTypes定义jdbcType类型 在自定义结果集标签或者参数处理的时候声明使用自定义TypeHandler进行处理，或者在全局配置TypeHandler要处理的javaType","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://lwblog.xyz/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://lwblog.xyz/tags/mybatis/"}]},{"title":"学习计划","slug":"学习计划","date":"2020-06-10T13:11:13.000Z","updated":"2020-06-10T14:17:56.921Z","comments":true,"path":"posts/5e21c553.html","link":"","permalink":"http://lwblog.xyz/posts/5e21c553.html","excerpt":"","text":"Java基础和框架学习计划 Spring Boot视频教程（上）核心技术篇 Spring Boot视频教程（下）整合篇 JAVA常用类 MyBatis-Plus 通用Mapper JVM SpringCloud 尚硅谷Dubbo视频 redis JDBC升级版 Java8新特性 JUC NIO","categories":[{"name":"学习计划","slug":"学习计划","permalink":"http://lwblog.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"http://lwblog.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"}]},{"title":"Maven学习笔记","slug":"Maven学习笔记","date":"2020-06-05T05:33:18.000Z","updated":"2020-06-05T05:36:44.215Z","comments":true,"path":"posts/be02a930.html","link":"","permalink":"http://lwblog.xyz/posts/be02a930.html","excerpt":"","text":"1.Maven 简介Maven是Apache软件基金会组织维护的一款自动化构建工具专注服务于Java平台的项目构建和依赖管理 。 2. 构建过程的主要几个环节①清理 ：删除以前的编译结果，为重新编译做好准备。②编译 ：将Java源程序编译为字节码文件。③测试 ：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。④报告 ：在每一次测试后以标准的格式记录和展示测试结果。⑤打包 ：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java工程对应jar包，Web工程对应war包。⑥安装 ：在 Maven 环境下特指将打包的结果jar包或war包安装到本地仓库中。⑦部署 ：将打包的结果部署到远程仓库或将war包部署到服务器上运行。 3.maven程序安装 maven下载 Binary：编译之后的二进制文件 Source：表示可以查看源代码的，比Binary大一点 tar.gz archive：Linux、macOS系统使用 zip archive：windows系统使用 解压到本地,注意解压的目录下不要有中文 配置环境变量 mac打开terminel输入以下命令：vim ~/.bash_profile打开.bash_profile文件，在次文件中添加设置环境变量的命令 123export M2_HOME&#x3D; ***这里换成自己解压maven的地址***&#x2F;&#x2F;示例：export M2_HOME&#x3D;&#x2F;Users&#x2F;XXX&#x2F;Maven&#x2F;apache-maven-3.6.3export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin 添加之后保存并推出，执行以下命令使配置生效：source ~/.bash_profile mac中解决source ~/.bash_profile关闭终端后在打开不生效的问题,需要在~/.zshrc文件最后，增加一行：source ~/.bash_profile。如果没有此文件可以使用vim ~/.zshr新建一个文件，在添加对应的命令 win 参考WIN10下安装配置mave文章进行配置 4.配置maven本地仓库4.1 仓库的分类 本地仓库:为当前本机电脑上的所有Maven工程服务。 远程仓库 私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务。 中央仓库：架设在 Internet 上，为全世界所有Maven工程服务。 中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 4.2 本地仓库的配置在 conf/setting.xml的文件中更改默认的仓库位置,也就是我们jar包下载后存放的位置 12&lt;!--需要添加的配置--&gt; &lt;localRepository&gt;&#x2F;Users&#x2F;wangyufei&#x2F;Maven&#x2F;repository&lt;&#x2F;localRepository&gt; 5.maven的标准目录结构 6.maven的常用命令6.1 clean命令清除编译产生的target文件夹内容，可以配合相应命令一起使用，如mvn clean package， mvn clean test 6.2 complie命令该命令可以对src/main/java目录的下的代码进行编译 6.3 test命令测试命令,或执行src/test/java/下junit的测试用例 6.4 package命令mvn package，打包项目 6.5 install命令mvn install，打包后将其安装在本地仓库 7. maven的生命周期7.1 Maven 有三套相互独立的生命周期 Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，安装，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。它们是相互独立的，你可以仅仅调用clean 来清理工作目录，仅仅调用 site 来生 成站点。 当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。 8. maven的概念模型图8.1 POMProject Object Model：项目对象模型。将 Java 工程 的相关信息封装为 对象 作为便于操作和管理的 模型 。Maven 工程的核心配置。可以说学习Maven 就是学习 pom.xml 文件中的配置。 8.2 Maven 的坐标使用如下三个向量在Maven的仓库中唯一的确定一个Maven工程。 groupid：公司或组织的域名倒序当前项目名称 artifactId：当前项目的模块名称 version：当前模块的版本 123&lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;&lt;artifactId&gt;wugujiawebmaven&lt;&#x2F;artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; 8.3 如何通过坐标到仓库中查找 jar包 将 gav 三个向量连起来org.example+wugujiawebmaven+1.0-SNAPSHOT 以连起来的字符串作为目录结构到仓库中查找org/example/wugujiawebmaven/1.0-SNAPSHOT ※注意：我们自己的Maven工程必须执行安装操作才会进入仓库 。安装的命令是： mvn install 9. idea集成maven插件配置创建java工程-DarchetypeCatalog=local 是为了防止在无网络的情况下可是使用本地已经下载好的maven的骨架配置路径如下： 10. 使用骨架创建maven的java工程 11. 不实用骨架创建maven的java工程 12. 使用骨架创建maven的web工程 创建web工程 创建好的javaweb工程(图1)，所以我们需要手动添加一个java的目录用于编写java代码(图2）,还要将java目录添加为Source Root(图3) 13. 创建自定义的JavaWeb工程创建web工程信息创建好的javaweb工程目录如图所示 14.idea中执行maven的命令 clean、test、complie、package、install的命令输入方法相同 15. Maven插件Maven是一个核心引擎，提供了基本的项目处理能力和建设过程的管理，以及一系列的插件是用来执行实际建设任务。maven插件可以完成一些特定的功能。例如，集成jdk插件可以方便的修改项目的编译环境；集成tomcat插件后，无需安装tomcat服务器就可以运行tomcat进行项目的发布与测试。在pom.xml中通过plugin标签引入maven的功能插件。 15.1 JDK编译版本的插件123456789101112&lt;!-- jdk版本插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt; &lt;showWarnings&gt;true&lt;&#x2F;showWarnings&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; 15.2 Tomcat7服务端的插件12345678910&lt;!-- tomcat7插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;&#x2F;port&gt; &lt;server&gt;tomcat7&lt;&#x2F;server&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; tomcat插件注意问题Maven的中央仓库中只有Tomcat7.X版本的插件，而之前我们使用的是8.X的版本，如果想使用Tomcat8.X的插件可以去其他第三方仓库进行寻找，或者使用IDEA集成外部Tomcat8极其以上版本，进行项目的发布 16. 依赖范围 compile 编译、测试、运行，A在编译时依赖B，并且在测试和运行时也依赖 strus-core、spring-beans。打到war包或jar包 provided 编译、和测试有效，A在编译和测试时需要B servlet-api就是编译和测试有用，在运行时不用（tomcat容器已提供）不会打到war runtime：测试、运行有效 在运行和测试时需要通过jdbc驱动包（mysql驱动）连接数据库，需要的会打到war test：只是测试有效，只在单元测试类中用 例如：junit 不会打到war 按照依赖强度，由强到弱来排序：(理解) compile&gt; provided&gt; runtime&gt; test 17. maven倒入jar包冲突解决 路径最短者优先 路径相同时先声明者优先。这里声明的先后顺序指的是dependency标签配置的先后顺序。 使用&lt;exclusions&gt;标签排除 12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.a tguigu.maven&lt;&#x2F;groupId&gt; &lt;artifactId&gt;HelloFriend&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1 SNAPSHOT&lt;&#x2F;version&gt; &lt;type&gt;jar&lt;&#x2F;type&gt; &lt;scope&gt;compile&lt;&#x2F;scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons logging&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons logging&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt; 18. 统一管理所依赖的版本对同一个框架的一组jar包最好使用相同的版本。为了方便升级框架，可以将 jar 包的版本信息统一提取出来 统一声明版本号 12345 &#x2F;&#x2F;其中atguigu.spring.version 部分 是自定义标签 &lt;properties&gt; &lt;atguigu.spring.version&gt;4.1.1.RELEASE&lt;&#x2F;atguigu.s pring.version&gt;&lt;&#x2F;properties&gt; 引用前面声明的版本号 12345678 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;springcore&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;atguigu.spring. version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; ……&lt;&#x2F;dependencies&gt; 完整示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt; &lt;artifactId&gt;ssm_parent_331&lt;&#x2F;artifactId&gt; &lt;packaging&gt;pom&lt;&#x2F;packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;modules&gt; &lt;module&gt;ssm_dao_331&lt;&#x2F;module&gt; &lt;module&gt;ssm_service_331&lt;&#x2F;module&gt; &lt;module&gt;ssm_web_331&lt;&#x2F;module&gt; &lt;module&gt;ssm_domain_331&lt;&#x2F;module&gt; &lt;module&gt;ssm_utils_331&lt;&#x2F;module&gt; &lt;&#x2F;modules&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;&#x2F;maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.version&gt; &lt;spring.security.version&gt;5.0.2.RELEASE&lt;&#x2F;spring.security.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;!-- spring相关的jar包 --&gt; &lt;!-- 容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 事务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- springMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.4.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mybatis与Spring整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- AOP切面 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;1.8.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.9&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- servletAPI --&gt; &lt;!-- JSP应用 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- servlet应用 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt; &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;!-- 日志记录工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.17&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j-api&lt;&#x2F;artifactId&gt; &lt;version&gt;2.10.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j-core&lt;&#x2F;artifactId&gt; &lt;version&gt;2.10.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j-web&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.25&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;log4j-jcl&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.6&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!--oracle的jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;&#x2F;groupId&gt; &lt;artifactId&gt;ojdbc14&lt;&#x2F;artifactId&gt; &lt;version&gt;10.2.0.2.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;&#x2F;groupId&gt; &lt;artifactId&gt;standard&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt; &lt;version&gt;2.5&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt; &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-security-web&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-security-config&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-security-core&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 19. maven工程的拆分与聚合19.1 创建父工程(只需要有pom.xnl文件)父工程中可以将src的文件夹删除掉,只留下pom.xml文件 19.2 子模块的创建 19.3 工程和模块的区别区别： 工程不等于完整的项目,模块也不等于一个完整的项目。代码完整,就可以说这是一个完整的项目和此项目和模块没有关系 工程只能使用自己的内部资源,工程天生时独立的。后天可以和其他工程和模块建立关联关系 模块天生是属于父工程的,模块一旦创建,所有父工程的资源都可以使用 关系： 父子工程中,子模块天生集成父工程,可以使用父工程所有的资源 子模块之间是没有关联的 子模块之间可以使用denpendency之间来互相引用,建立关联 平级之间引用叫做依赖,依赖不是先天的,是后天建立的 父子工程之间不用建立关系,继承关系是先天的,不需要手动建立 19.4 maven父子工程三种启动方式 可以在父工程中使用 mvn run 使用web模块中启动时,需要先将其依赖的jar发布到本地仓库或者远程仓库中 添加本地的tomcat,不在使用maven中自带的tomcat 19.5 搭建maven的私服环境 下载nexusNexus 是Maven仓库管理器，通过nexus可以搭建maven仓库，同时nexus还提供强大的仓库管理功能，构件搜索功能等。 Centos7上搭建私服 上传到Centos7服务器 使用命令tar -avxf nexus-3.23.0-03-unix.tar.gz解压完成后会出现一下两个文件(一个是nexus服务,一个是私有仓库) 修改默认的端口 启动nexus启动 Nexus（默认端口是8081），Nexus 常用的一些命令包括：/nexus-3.23.0-03/bin/nexus {start|stop|run|run-redirect|status|restart|force-reload}，下面我们启动Nexus： 1234WARNING: ************************************************************WARNING: Detected execution as &quot;root&quot; user. This is NOT recommended!WARNING: ************************************************************Starting nexus 上面在启动过程中出现警告：“不推荐使用root用户启动”。这个警告不影响Nexus的正常访问和使用。 如果上面的环境变量配置了,试着修改 1&#x2F;bin&#x2F;nexus.rc文件中的run_as_user&#x3D; “root” 19.6 私服的应用19.6.1 账号和密码是固定的 admin/admin12319.6.2 登陆私服的配置(server.xml) 12345678910&lt;server&gt; &lt;id&gt;releases&lt;&#x2F;id&gt; &lt;username&gt;admin&lt;&#x2F;username&gt; &lt;password&gt;admin123&lt;&#x2F;password&gt; &lt;&#x2F;server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;&#x2F;id&gt; &lt;username&gt;admin&lt;&#x2F;username&gt; &lt;password&gt;admin123&lt;&#x2F;password&gt; &lt;&#x2F;server&gt; 19.6.3 配置项目pom.xml配置私服仓库的地址，本公司的自己的jar包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库 123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;release&lt;&#x2F;id&gt; &lt;name&gt;Release Repository&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;ip&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;releases&lt;&#x2F;url&gt; &lt;&#x2F;repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshot&lt;&#x2F;id&gt; &lt;name&gt;Snapshot Repository&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;ip&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;snapshots&lt;&#x2F;url&gt; &lt;&#x2F;snapshotRepository&gt;&lt;&#x2F;distributionManagement&gt; 注意：pom.xml这里 和 settings.xml 配置 对应！ 19.6.4 相关jar包的下载123456789101112131415161718192021222324&lt;!-- 下载jar包配置 --&gt; &lt;profile&gt; &lt;!--profile的id --&gt; &lt;id&gt;dev&lt;&#x2F;id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库id，repositories可以配置多个仓库，保证id不重复 --&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;!--仓库地址，即nexus仓库组的地址 --&gt; &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;!--是否下载releases构件 --&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;&#x2F;enabled&gt; &lt;&#x2F;releases&gt; &lt;!--是否下载snapshots构件 --&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;&#x2F;enabled&gt; &lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;&#x2F;repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;&#x2F;id&gt; &lt;name&gt;Public Repositories&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;&#x2F;pluginRepository&gt; &lt;&#x2F;pluginRepositories&gt; &lt;&#x2F;profile&gt; 123&lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;&#x2F;activeProfile&gt; &lt;&#x2F;activeProfiles&gt; 19.6.5 安装第三方jar包到本地仓库和私服 安装第三方jar包到本地仓库 1234----进入jar包所在目录运行mvn install:install-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dfile&#x3D;fastjson-1.1.37.jar -Dpackaging&#x3D;jar----打开cmd直接运行mvn install:install-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dpackaging&#x3D;jar -Dfile&#x3D;C:\\my_java\\授课资料\\资料：maven【高级】\\安装第三方jar包\\fastjson-1.1.37.jar 安装第三方jar包到私服 12345678910--在settings配置文件中添加登录私服第三方登录信息&lt;server&gt;&lt;id&gt;thirdparty&lt;&#x2F;id&gt;&lt;username&gt;admin&lt;&#x2F;username&gt;&lt;password&gt;admin123&lt;&#x2F;password&gt;&lt;&#x2F;server&gt;----进入jar包所在目录运行mvn deploy:deploy-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dpackaging&#x3D;jar -Dfile&#x3D;fastjson-1.1.37.jar -Durl&#x3D;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;thirdparty&#x2F; -DrepositoryId&#x3D;thirdparty----打开cmd直接运行mvn deploy:deploy-file -DgroupId&#x3D;com.alibaba -DartifactId&#x3D;fastjson -Dversion&#x3D;1.1.37 -Dpackaging&#x3D;jar -Dfile&#x3D;C:\\my_java\\授课资料\\资料：maven【高级】\\安装第三方jar包\\fastjson-1.1.37.jar -Durl&#x3D;http:&#x2F;&#x2F;localhost:8081&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;thirdparty&#x2F; -DrepositoryId&#x3D;thirdparty 20. 配置全局的jdk1234567891011121314&lt;!--配置全局的jdk为1.8--&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt;","categories":[{"name":"java","slug":"java","permalink":"http://lwblog.xyz/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://lwblog.xyz/tags/maven/"}]},{"title":"IDEA中查看maven的依赖关系","slug":"IDEA中查看maven的依赖关系","date":"2020-06-05T05:32:58.000Z","updated":"2020-06-05T05:36:44.215Z","comments":true,"path":"posts/c9331070.html","link":"","permalink":"http://lwblog.xyz/posts/c9331070.html","excerpt":"","text":"1. 使用maven自带的工具1.1 确保idea中UML的插件可以使用 1.2 pom.xml文件依赖分析 在需要分析的pom.xml文件中右键选择maven-&gt;Show Dependencies打开后的图形 使用技巧 按住option,移动鼠标会出现放大镜,放大当前的依赖 按住control,滚轮向前 放大整个屏幕 红色实现表示冲突的文件,右键，排除，他就自动在pom文件里面给exclud啦 红色的虚线表示用一个jar包都在哪里被多次引用 2. 使用maven helper插件 打开需要查看的pom.xml文件,下边会出现Denpendency Anlyzar，点击按钮 菜单功能 Conflicts：冲突 All Dependencies as List：列表形式查看所有依赖 All Dependencies as Tree：树结构查看所有依赖 冲突jar包的解决 切换到maven 依赖视图选择冲突选项，如果有冲突，在左下面区域会有红色显示。 解决冲突，右键单击红色区域，弹出菜单选择Exclude命令，对冲突进行排除","categories":[{"name":"java","slug":"java","permalink":"http://lwblog.xyz/categories/java/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://lwblog.xyz/tags/maven/"}]},{"title":"Activiti6.0工作流引擎学习(二) -- 引擎配置","slug":"Activiti6-0工作流引擎学习(二)","date":"2020-05-28T03:09:05.000Z","updated":"2020-05-28T03:15:06.231Z","comments":true,"path":"posts/1d8f65f1.html","link":"","permalink":"http://lwblog.xyz/posts/1d8f65f1.html","excerpt":"","text":"Activiti6.0工作流引擎学习(二) – 引擎配置1.Activiti流程引擎配置涉及的类 1.1 流程引擎配置类的作用 ProcessEngineConfiguration 查找并解析xml配置文件activiti.cfg.xml 提供多个静态方法创建配置对象 实现几个基于不同场景场景的子类，配置方式非常的灵活 1.2 部分子类的使用12345678910111213@Test public void testConfig1()&#123; //通过默认来创建引擎；会通过spring的解析进行创建引擎对象 ProcessEngineConfiguration engine = ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault(); log.info(\"engine =&#123;&#125;\",engine); &#125; @Test public void testConfig2()&#123; //直接创建标准的引擎，直接new一个引擎对象 ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); log.info(\"configuration = &#123;&#125;\",configuration); &#125; 2.数据库配置2.1 缺省配置默认，使用H2内存数据库2.2 配置JDBC属性，使用mybatis提供的链接池 2.3 配置DataSource，可自选第三方实现 Druid 为监控而生的数据库连接池 来自阿里 Dbcp 老牌数据源连接池，稳定可靠，Tomcat自带 HikariCP 来自日本的极速数据源连接池，Spring默选 2.4 数据库更新策略 配置databaseSchemaUpdate false：启动时检查数据库版本，发生不匹配抛异常 true: 启动时自动检查并甭信数据库表，不存在会创建 create-drop: 启动时创建数据库表结构，结束时删除表结构 2.5 数据库配置编码2.5.1 使用默认的配置文件创建流程引擎activiti.cfg.xml文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\"&gt; &lt;!--&lt;property name=\"jdbcUrl\" value=\"jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000\" /&gt; &lt;property name=\"jdbcDriver\" value=\"org.h2.Driver\" /&gt; &lt;property name=\"jdbcUsername\" value=\"sa\" /&gt; &lt;property name=\"jdbcPassword\" value=\"\" /&gt; &amp;lt;!&amp;ndash; Database configurations &amp;ndash;&amp;gt; &lt;property name=\"databaseSchemaUpdate\" value=\"drop-create\" /&gt; &lt;property name=\"history\" value=\"full\" /&gt;--&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678public void test1()&#123; ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResourceDefault(); log.info(\"configuration = &#123;&#125;\",configuration); ProcessEngine processEngine = configuration.buildProcessEngine(); log.info(\"获取流程引擎 = [&#123;&#125;]\",processEngine.getName()); processEngine.close(); &#125; 2.5.2 使用druid数据源activiti_druid.cfg.xml配置文件 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\"&gt; &lt;!--&lt;property name=\"jdbcUrl\" value=\"jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000\" /&gt; &lt;property name=\"jdbcDriver\" value=\"org.h2.Driver\" /&gt; &lt;property name=\"jdbcUsername\" value=\"sa\" /&gt; &lt;property name=\"jdbcPassword\" value=\"\" /&gt; &amp;lt;!&amp;ndash; Database configurations &amp;ndash;&amp;gt;--&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"drop-create\" /&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"history\" value=\"full\" /&gt; &lt;!--引擎是否使用历史数据--&gt; &lt;property name=\"dbHistoryUsed\" value=\"true\"/&gt; &lt;!--引擎是否使用身份验证--&gt; &lt;property name=\"dbIdentityUsed\" value=\"true\"/&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"url\" value=\"jdbc:mysql://111.229.203.5:3306/activiti?serverTimezone=CTT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;allowMultiQueries=true\"/&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"username\" value=\"weaver\"/&gt; &lt;property name=\"password\" value=\"192612\"/&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"maxActive\" value=\"10\"/&gt; &lt;property name=\"filters\" value=\"stat,slf4j\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678public void test2()&#123; ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(\"activiti_druid.cfg.xml\"); log.info(\"configuration = &#123;&#125;\",configuration); ProcessEngine processEngine = configuration.buildProcessEngine(); log.info(\"获取流程引擎 = [&#123;&#125;]\",processEngine.getName()); processEngine.close(); &#125; 3.日志记录配置3.1 日志组件的关系及MDC 3.1.1 配置开启MDC(Mapped Diagnostic Contexts) 默认没有开启，需要手动设置LogMDC.setMDCEnable(true) 配置logback.xml日志模版 %X{mdcProcessInstanceID} 流程只有在执行过程出现异常才会记录MDC信息 3.2 配置历史记录级别(HistoryLevel)3.2.1 配置HistoryLevel none:不记录历史流程，性能高，流程结束后不可读取 activiti:归档流程实例和活动实例，流程变量不同步 addit:默认值，在activiti基础上同步变量值，保存表单属性 full:性能较差，记录所有实例和变量细节变化 3.3 配置基于db的事件日志(Event logging)3.3.1 配置Event Logging 试验性的事件记录机制，性能影响较大 开启默认记录所有数据的变化过程，表记录快速增长 日志内容json格式，建议存入mongoDB、Elastic Search 3.4 日志记录 mdc4 历史记录配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.atguigu.test;import com.google.common.collect.Maps;import org.activiti.engine.history.HistoricActivityInstance;import org.activiti.engine.history.HistoricDetail;import org.activiti.engine.runtime.Execution;import org.activiti.engine.runtime.ProcessInstance;import org.activiti.engine.task.Task;import org.activiti.engine.test.ActivitiRule;import org.activiti.engine.test.Deployment;import org.junit.Rule;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.List;import java.util.Map;/** * @program: activiti6 * @description: 测试MDC * @author: Mr.Wang * @create: 2020-14-31 */public class TestMDC &#123; private static Logger log = LoggerFactory.getLogger(TestMDC.class); @Rule public ActivitiRule activitiRule = new ActivitiRule(); @Test //定义流程文件部署 @Deployment(resources = &#123;\"my-process.bpmn20.xml\"&#125;) public void test()&#123; Map&lt;String,Object&gt; params = Maps.newHashMap(); params.put(\"keyStart1\",\"value1\"); params.put(\"keyStart2\",\"value2\"); //启动流程 ProcessInstance processInstance = activitiRule.getRuntimeService().startProcessInstanceByKey(\"my-process\",params); //修改变量 List&lt;Execution&gt; executions = activitiRule.getRuntimeService().createExecutionQuery().listPage(0, 100); for (Execution execution : executions) &#123; log.info(\"executions &#123;&#125;\",executions); &#125; log.info(\"executions size = &#123;&#125;\",executions.size()); String id = executions.iterator().next().getId(); activitiRule.getRuntimeService().setVariable(id,\"keyStart1\",\"value1_\"); //提交表单task 修改变量 Task task = activitiRule.getTaskService().createTaskQuery().singleResult(); Map&lt;String,String&gt; properties = Maps.newHashMap(); properties.put(\"formkey1\",\"valuef1\"); properties.put(\"formkey2\",\"valuef2\"); activitiRule.getFormService().submitTaskFormData(task.getId(),properties); //activitiRule.getTaskService().complete(task.getId()); //输出历史活动 List&lt;HistoricActivityInstance&gt; historicActivityInstances = activitiRule.getHistoryService().createHistoricActivityInstanceQuery().listPage(0, 100); for (HistoricActivityInstance historicActivityInstance : historicActivityInstances) &#123; log.info(\"historicActivityInstances = &#123;&#125;\",historicActivityInstances); &#125; log.info(\"historicActivityInstances size = &#123;&#125;\",historicActivityInstances.size()); //输出历史表单 //输出历史详情 List&lt;HistoricDetail&gt; historicDetails = activitiRule.getHistoryService().createHistoricDetailQuery().listPage(0, 100); for (HistoricDetail historicDetail : historicDetails) &#123; log.info(\"historicDetail [&#123;&#125;]\",historicDetail); &#125; log.info(\"historicDetail size = [&#123;&#125;]\", historicDetails.size()); &#125;&#125; 5.事件处理及监听配置-eventlog5.1 事件及监听器原理 5.2 监听器的配置方式 配置Listener eventListeners:监听所有事件派发通知 typedEventListeners:监听指定事件类型的通知 activiti:eventListener:只监听特定流程定义的事件 5.3 Activiti事件监听5.3.1 相关API ActivitiEvent:事件对象 ActivitiEventListener:监听器 ActivitiEventType:事件类型 5.4 ActivitiEventListener监听器的使用 配置文件中增加对应的配置 1234567&lt;!--配置事件监听器--&gt; &lt;property name=\"eventListeners\"&gt; &lt;list&gt; &lt;!--监听器的实现类--&gt; &lt;bean class=\"com.atguigu.event.ProcessEventListener\"/&gt; &lt;/list&gt; &lt;/property&gt; 创建一个实体类，实现ActivitiEventListener类 123456789101112131415161718192021222324252627282930313233package com.atguigu.event;import org.activiti.bpmn.model.ActivitiListener;import org.activiti.engine.delegate.event.ActivitiEvent;import org.activiti.engine.delegate.event.ActivitiEventListener;import org.activiti.engine.delegate.event.ActivitiEventType;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @program: activiti6 * @description: 流程监听 * @author: Mr.Wang * @create: 2020-05-27-21-26 */public class ProcessEventListener implements ActivitiEventListener &#123;private static Logger log = LoggerFactory.getLogger(ProcessEventListener.class); @Override public void onEvent(ActivitiEvent event) &#123; ActivitiEventType type = event.getType(); //判断是是否为流程启动 if(ActivitiEventType.PROCESS_STARTED.equals(type))&#123; log.info(\"流程启动 &#123;&#125;\",event.getProcessInstanceId()); &#125;else if(ActivitiEventType.PROCESS_COMPLETED.equals(type))&#123; log.info(\"流程结束\"); &#125; &#125; @Override public boolean isFailOnException() &#123; return false; &#125;&#125; 5.5 TypedEventListeners监听器的使用 配置文件 12345678910&lt;property name=\"typedEventListeners\"&gt; &lt;map&gt; &lt;!--这样配置的时候，只会监听流程启动--&gt; &lt;entry key=\"PROCESS_STARTED\"&gt; &lt;list&gt; &lt;bean class=\"com.atguigu.event.ProcessEventListener\"/&gt; &lt;/list&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; 流程监听实体类 12345678910111213141516171819202122232425262728293031323334package com.atguigu.event;import org.activiti.bpmn.model.ActivitiListener;import org.activiti.engine.delegate.event.ActivitiEvent;import org.activiti.engine.delegate.event.ActivitiEventListener;import org.activiti.engine.delegate.event.ActivitiEventType;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * @program: activiti6 * @description: 流程监听 * @author: Mr.Wang * @create: 2020-05-27-21-26 */public class ProcessEventListener implements ActivitiEventListener &#123;private static Logger log = LoggerFactory.getLogger(ProcessEventListener.class); @Override public void onEvent(ActivitiEvent event) &#123; ActivitiEventType type = event.getType(); //判断是是否为流程启动 if(ActivitiEventType.PROCESS_STARTED.equals(type))&#123; log.info(\"流程启动 &#123;&#125;\",event.getProcessInstanceId()); &#125;else if(ActivitiEventType.PROCESS_COMPLETED.equals(type))&#123; log.info(\"流程结束\"); &#125; &#125; @Override public boolean isFailOnException() &#123; return false; &#125;&#125;//输出的结果为：22:18:38.450 [main] [INFO ]流程启动 4 c.a.e.ProcessEventListener.onEvent:23 6. 命令拦截器配置–command6.1 命令模式与责任链模式6.1.1 命令模式 6.1.2 责任链模式 CommandInterceptor 配置Interceptor customPreCommandInterceptors:配置在默认拦截器之前 customPostCommandInterceptors:配置在默认拦截器之后 commandInvoker:配置最后的执行器 6.2 拦截器的配置方式 activiti.cfg.xml文件的修改 123456&lt;!--拦截器的配置--&gt; &lt;property name=\"customPreCommandInterceptors\"&gt; &lt;list&gt; &lt;bean class=\"com.atguigu.interceptor.DurationInterceptor\"/&gt; &lt;/list&gt; &lt;/property&gt; 实体类的编写 1234567891011121314151617181920212223package com.atguigu.interceptor;import org.activiti.engine.impl.interceptor.AbstractCommandInterceptor;import org.activiti.engine.impl.interceptor.Command;import org.activiti.engine.impl.interceptor.CommandConfig;/** * @program: activiti6 * @description: 执行的时间 * @author: Mr.Wang * @create: 2020-05-27-22-53 */public class DurationInterceptor extends AbstractCommandInterceptor &#123; @Override public &lt;T&gt; T execute(CommandConfig config, Command&lt;T&gt; command) &#123; long l = System.currentTimeMillis(); this.getNext().execute(config,command); long l1 = System.currentTimeMillis(); long duration = l1 - l; System.out.println(\"执行的时长-----&gt;\"+duration); return null; &#125;&#125; 6.3 Activiti的拦截器 7. 作业执行器 Job Executor7.1 作业执行器配置（1） asyncExecutorActivate:激活作业执行器（2） asyncExectuorXXX:异步执行器的属性配置（3） asyncExecutor:异步执行器的bean 7.2 配置自定义线程池7.2.1 自定义线程池ExecutorService（1） corePoolSize:核心线程数（2） maxPoolSize: 最大线程数（3） queueCapacity:堵塞队列大小 7.2.2 基于spring线程池的配置 7.3 流程定义定时启动流程7.3.1 定时开始事件 timeDate：指定启动时间 timeDuration:指定持续时间间隔后执行 timeCycle:R5/P1DT1H指定事件段后周期执行 7.4 配置文件修改activiti.cfg.xml文件修改 12345678910111213141516&lt;bean id&#x3D;&quot;processEngineConfiguration&quot; class&#x3D;&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt; &lt;!--打开定时任务的激活器--&gt; &lt;property name&#x3D;&quot;asyncExecutorActivate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;!--定义异步执行器--&gt; &lt;property name&#x3D;&quot;asyncExecutor&quot; ref&#x3D;&quot;defaultAsyncJobExecutor&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--系统默认的自定义任务执行器--&gt; &lt;bean id &#x3D; &quot;defaultAsyncJobExecutor&quot; class&#x3D;&quot;org.activiti.engine.impl.asyncexecutor.DefaultAsyncJobExecutor&quot;&gt; &lt;!--需要的服务--&gt; &lt;property name&#x3D;&quot;executorService&quot; ref&#x3D;&quot;executorService&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--使用spring的线程池--&gt; &lt;bean id &#x3D; &quot;executorService&quot; class&#x3D;&quot;org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean&quot;&gt; &lt;!--具体的配置--&gt; &lt;&#x2F;bean&gt; 8 Activiti与Spring的集成8.1 集成Spring配置8.1.1 相关配置(1) 添加pom依赖activiti-spring 123456&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.activiti&#x2F;activiti-spring --&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;&#x2F;groupId&gt; &lt;artifactId&gt;activiti-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;6.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; (2) 基于Spring的默认配置activiti-context.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;!--数据源配置--&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;111.229.203.5:3306&#x2F;activiti?serverTimezone&#x3D;CTT&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;allowMultiQueries&#x3D;true&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;weaver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;192612&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;initialSize&quot; value&#x3D;&quot;1&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;10&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;filters&quot; value&#x3D;&quot;stat,slf4j&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--事务管理器配置--&gt; &lt;bean id&#x3D;&quot;dataSourceTransactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--指定数据源--&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;processEngineConfiguration&quot; class&#x3D;&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;!--配置事务管理--&gt; &lt;property name&#x3D;&quot;transactionManager&quot; ref&#x3D;&quot;dataSourceTransactionManager&quot;&#x2F;&gt; &lt;!--数据源的创建格式--&gt; &lt;property name&#x3D;&quot;databaseSchemaUpdate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;&#x2F;bean&gt; &lt;!--构造流程引擎对象--&gt; &lt;bean id &#x3D; &quot;processEngineFactoryBean&quot; class&#x3D;&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt; &lt;!--指定流程配置对象--&gt; &lt;property name&#x3D;&quot;processEngineConfiguration&quot; ref&#x3D;&quot;processEngineConfiguration&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;!--报漏服务给Spring--&gt; &lt;bean id&#x3D;&quot;runtimeService&quot; factory-bean&#x3D;&quot;processEngineFactoryBean&quot; factory-method&#x3D;&quot;getRuntimeService&quot;&gt;&lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;repositoryService&quot; factory-bean&#x3D;&quot;processEngineFactoryBean&quot; factory-method&#x3D;&quot;getRepositoryService&quot;&gt;&lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;formService&quot; factory-bean&#x3D;&quot;processEngineFactoryBean&quot; factory-method&#x3D;&quot;getFormService&quot;&gt;&lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;taskService&quot; factory-bean&#x3D;&quot;processEngineFactoryBean&quot; factory-method&#x3D;&quot;getTaskService&quot;&gt;&lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;historyService&quot; factory-bean&#x3D;&quot;processEngineFactoryBean&quot; factory-method&#x3D;&quot;getHistoryService&quot;&gt;&lt;&#x2F;bean&gt; &lt;bean id&#x3D;&quot;activitiRule&quot; class&#x3D;&quot;org.activiti.engine.test.ActivitiRule&quot;&gt; &lt;property name&#x3D;&quot;processEngine&quot; ref&#x3D;&quot;processEngineFactoryBean&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; (3) Activiti核心服务注入Spring容器详细配置见上一步 8.2 基于Spring对Activiti管理8.2.1 功能特征(1) 集成Spring事务管理器(2) 定义文件表达式中使用Spring bean(3) 自动部署资源文件 8.3 基于Spring的流程单元测试8.3.1 单元测试（1） 添加pom依赖spring-test 1234567&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;&#x2F;version&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt; （2） 辅助测试Rule:ActivitiRule 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.atguigu.test;import org.activiti.engine.RuntimeService;import org.activiti.engine.TaskService;import org.activiti.engine.runtime.ProcessInstance;import org.activiti.engine.task.Task;import org.activiti.engine.test.ActivitiRule;import org.activiti.engine.test.Deployment;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;/** * @program: activiti6 * @description: 测试与Spring的集成 * @author: Mr.Wang * @create: 2020-05-28-10-26 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:activiti-context.xml\"&#125;)public class TestSpring &#123; private static Logger log = LoggerFactory.getLogger(TestSpring.class); @Rule @Autowired public ActivitiRule activitiRule; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Test @Deployment(resources = &#123;\"my-process.bpmn20.xml\"&#125;) public void test()&#123; ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(\"my-process\"); /*List&lt;Task&gt; tasks = taskService.createTaskQuery().listPage(0, 100); for (Task task : tasks) &#123; log.info(\"task 的某些测试数据 &#123;&#125;\",task); &#125;*/ Task task = taskService.createTaskQuery().singleResult(); taskService.complete(task.getId()); &#125;&#125; （3） 辅助测试TestCase:SpringActivitiTestCase","categories":[{"name":"java","slug":"java","permalink":"http://lwblog.xyz/categories/java/"}],"tags":[{"name":"activiti6.0","slug":"activiti6-0","permalink":"http://lwblog.xyz/tags/activiti6-0/"}]},{"title":"Java8日期和时间处理","slug":"Java8日期和时间处理","date":"2020-05-21T14:13:14.000Z","updated":"2020-05-25T14:51:07.708Z","comments":true,"path":"posts/58f1702a.html","link":"","permalink":"http://lwblog.xyz/posts/58f1702a.html","excerpt":"","text":"1.java8新特性-新时间与日期API本地时间与时间戳LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用ISO-8601的日历系统的日期、时间、日期和时间。新的API提供了简单的日期和时间的获取方法。不包含与时区有关的信息 1.1 使用静态方法now获取本地时间123456LocalDate now = LocalDate.now();System.out.println(\"获取系统的日期:\"+now);// 2020-05-25LocalTime localTime = LocalTime.now();System.out.println(\"获取系统的时间:\"+localTime);//20:32:55.091LocalDateTime localDateTime = LocalDateTime.now();System.out.println(\"获取系统的日期和时间:\"+localDateTime);//2020-05-25T20:32:55.092 1.2 使用静态方法of获取日期和时间123456LocalDate localDate = LocalDate.of(2012, 3, 23);System.out.println(localDate);//2012-03-23LocalTime localTime = LocalTime.of(12, 12);System.out.println(localTime);//12:12LocalDateTime localDateTime = LocalDateTime.of(2012, 3, 24, 12, 12, 12);System.out.println(localDateTime);//2012-03-24T12:12:12 1.3 plusDays、plusWeeks、plusMonths、plusYear向当前LocalDate对象添加几天、几周、几个月、几年12345678910LocalDate localDate = LocalDate.now();System.out.println(localDate);//2020-05-25LocalDate localDate1 = localDate.plusDays(2L);System.out.println(localDate1);//2020-05-27LocalDate localDate2 = localDate.plusMonths(2L);System.out.println(localDate2);//2020-07-25LocalDate localDate3 = localDate.plusWeeks(2L);System.out.println(localDate3);//2020-06-08LocalDate localDate4 = localDate.plusYears(2L);System.out.println(localDate4);//2022-05-25 1.4 Instant时间戳时间戳(以Unix元年：1970年1月1日00：00：00到某个时间之间的毫秒值) 123456789//默认获取的是以UTC时区Instant now = Instant.now();System.out.println(now);//2020-05-25T13:32:32.718Z//对时间进行偏移量处理,以便获取当前所在时区的时间OffsetDateTime offsetDateTime=now.atOffset(ZoneOffset.ofHours(8));System.out.println(offsetDateTime);//2020-05-25T21:32:32.718+08:00//把获取的时间转换成对应的毫秒值long l = now.toEpochMilli();System.out.println(l);//1590413552718 1.5 Duration计算两个时间之间的间隔,Period计算两个日期之间的间隔Duration和Period的使用方式相同 123456789101112131415161718Instant now = Instant.now();try &#123; //用线程睡眠一秒钟来测试Duration的时间差 Thread.sleep(1000L);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;Instant now2 = Instant.now();//比较两个时间的间隔Duration duration = Duration.between(now, now2);//默认输出`PT1.002S`为ISO-861的表示方法System.out.println(duration);//将ISO的表示的方法转换为纳秒、或者毫秒值long l = duration.toNanos();//1002000000//转换为毫秒值//long l1 = duration.toMillis();System.out.println(l);//System.out.println(l1); 2.java8新特性-新时间与日期API-时间校正器TemporalAdjuster:时间校正器。有时候我们需要获取例如：将日期调整到“下周日”等操作。TemporalAdjusters:该类通过静态方法提供了大量的常用TemporalAdjuster的实现 1234567891011121314151617181920LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);//2020-05-25T22:00:35.532//获取下一个周日LocalDateTime dateTime = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));System.out.println(dateTime);//2020-05-31T22:00:35.532//自定义：下一个工作日是什么时候LocalDateTime with = ldt.with(l -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; //获取今天是星期几 DayOfWeek dayOfWeek = ldt4.getDayOfWeek(); System.out.println(dayOfWeek);//MONDAY if (dayOfWeek.equals(DayOfWeek.FRIDAY)) &#123; return ldt4.plusDays(3L); &#125; else if (dayOfWeek.equals(DayOfWeek.SUNDAY)) &#123; return ldt4.plusDays(2L); &#125; else &#123; return ldt4.plusDays(1L); &#125; &#125;); System.out.println(with);//2020-05-26T22:06:51.576 3.java8新特性-新时间与日期API-时间格式化与时区处理3.1时间和日期的格式化123456789DateTimeFormatter isoLocalDate = DateTimeFormatter.ISO_LOCAL_DATE;LocalDateTime now = LocalDateTime.now();System.out.println(now);String format = now.format(isoLocalDate);//2020-05-25T22:22:48.083System.out.println(format);//2020-05-25//定义自己的格式DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日\");String format1 = dateTimeFormatter.format(now);System.out.println(format1);//2020年05月25日 3.2 时区的处理java8中加入了对时区的支持，带时区的时间分别为ZonedDate,ZonedTIme,ZoneDateTime。其中每个时区都对应着ID，地区ID都是区域/城市的格式，例如：Asia/Shanghai等。ZoneId该类中包含了所有的时区信息：getAvailableZoneIds():可以获取所有时区的信息of(id):用指定的时区信息获取ZoneId对象 12345678910//获取所有的时区Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();availableZoneIds.forEach(System.out::println);//获取时区为上海的时间LocalDateTime now = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\"));//2020-05-25T22:47:57.216System.out.println(now);//也可以使用以下的方法设置时区,返回的是带有时区的时间和日期LocalDateTime now1 = LocalDateTime.now();ZonedDateTime zonedDateTime = now1.atZone(ZoneId.of(\"Asia/Shanghai\"));//2020-05-25T22:47:57.222+08:00[Asia/Shanghai]System.out.println(zonedDateTime);","categories":[{"name":"java","slug":"java","permalink":"http://lwblog.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://lwblog.xyz/tags/java/"},{"name":"JDK1.8","slug":"JDK1-8","permalink":"http://lwblog.xyz/tags/JDK1-8/"}]},{"title":"谷歌浏览器调试技巧","slug":"谷歌浏览器调试技巧","date":"2020-05-18T01:14:32.000Z","updated":"2020-05-18T01:15:41.580Z","comments":true,"path":"posts/4cc93b7c.html","link":"","permalink":"http://lwblog.xyz/posts/4cc93b7c.html","excerpt":"","text":"","categories":[{"name":"google","slug":"google","permalink":"http://lwblog.xyz/categories/google/"}],"tags":[{"name":"调试","slug":"调试","permalink":"http://lwblog.xyz/tags/%E8%B0%83%E8%AF%95/"}]},{"title":"谷歌云盘折腾记","slug":"谷歌云盘折腾记","date":"2020-05-17T03:17:09.000Z","updated":"2020-05-22T13:47:44.551Z","comments":true,"path":"posts/af6fa0b3.html","link":"","permalink":"http://lwblog.xyz/posts/af6fa0b3.html","excerpt":"","text":"折腾原因前段时间由于某些原因，Goindex基于rclone挂载的谷歌云盘在某些原因的情况下不能免科学上网进行访问。这对于我这个大量文件都存放在谷歌云盘上的人来说就有点难受了。毕竟咱是一个无产阶级没有那么多的money进行购买机场流量。只能在茫茫的查找对应的替代品，功夫不负有心人。最终在努力下终于找到一个解决的办法，故此在这里记录一下 前期准备 能科学上网的环境(准备的情况下需要科学上网) rclone 下载安装rclone CLOUDFLARE 提前注册好账号 Goindex 现在已经不能用了，原先我就是用的这个 安装免科学上网访问谷歌云盘我是在参考YouTube上大佬小小白的视频进行操作的，这里附上大佬的视频链接。各位看官，可以先参考这位大佬的视频进行操作。如果顺利的话就能正常的免科学上网的访问自己的谷歌云盘了。但是，我偏偏是这个不幸中的一人。我按照视频的操作过程中，总是卡在获取谷歌云盘的token验证失败的情况，查了很多资料都没能解决此问题。如果你也遇到这样的问题话，可以参考我的做法。首先，你原先在GoIndex上生成过对应的代码，并且在cloudflare上部署过，下图是我部署代码的部分截图其次，需要在cloudflare上新建一个worked，将这里index.js的代码复制到刚刚新建的worked中，并且将下图中的ID、密钥和token替换成原先使用Goindex生成的代码中的ID、密钥和token。(这里之所以是这样做，是因为使用rclone生成token的时候总是报错)最后，保存并部署代码就OK了，这样就能再次在不科学上网的情况下继续浏览自己谷歌云盘中的内容了。在这次更新的代码中还有很多的改进，比如可以对不同的文件夹赋予不同的权限，能在进行搜索操作 GDIndex代码生成器虽然GoIndex代码生成器目前已经不能使用了，但是现在有一个新的GDIndex代码生成器可以替代GoIndex的代码生成器GDIndex的使用方法同GoIndex。需要的小伙伴可以自行百度设置，或者参考上面提到的视频。 文章参考： 小小白大佬的视频 小小白大佬的文档说明","categories":[{"name":"google","slug":"google","permalink":"http://lwblog.xyz/categories/google/"}],"tags":[{"name":"google diriver","slug":"google-diriver","permalink":"http://lwblog.xyz/tags/google-diriver/"}]},{"title":"macbookpro使用技巧","slug":"macbookpro使用技巧","date":"2020-05-15T04:48:36.000Z","updated":"2020-05-15T06:59:49.314Z","comments":true,"path":"posts/2366fd10.html","link":"","permalink":"http://lwblog.xyz/posts/2366fd10.html","excerpt":"","text":"1.mac的隐藏功能 直观听到音量的渐变声音: shfit+音量键 声音或者亮度1/4的变化：shfit+option+音量键/亮度建 聊天打字快速调出emoj动画：command+control+空格 切换显示已关闭或者最小化的窗口：command+tab同时摁下option 隐藏当前窗口的程序：command+H 区分关闭和隐藏的代码(开启后隐藏的图标呈现半透明状态) 1defaults write com.apple.Dock showhidden -bool TRUE; killall Dock 关闭的代码 1defaults write com.apple.Dock showhidden -bool FALSE; killall Dock command+tab选中图标后摁下Q是关闭程序 2. mac中常用软件3.mac的高效使用 一位数密码：pwpolicy -clearaccountpolicies 需要在终端执行此命令 更改搜索这台mac为搜索此文件夹 访达—偏好设置—高级—执行搜索选择搜索但前文件夹 打开程序的偏好设置： command+, 手动添加打开系统偏好设置的快捷键 系统偏好设置—键盘—快捷键—APP快捷键—点击“+”，应用程序选择所有应用程序，菜单标题改为“系统偏好设置…”,快捷键中输入自己熟悉的快捷键就OK—点击添加 全局开启访达 打开自动操作 点击新建文稿 快速操作 点击实用工具，将开启应用程序拖拽到右边 工作流程收到选择：没有输入 选择新建变量—系统—资源库—coreservices—访达 点击这里可以测试是否配置正确，然后存储 快捷键定义 通过系统偏好设置—键盘—快捷键—服务—通用—全局开启访达 ![image-20200515135133428](/Users/wangyufei/Library/Application Support/typora-user-images/image-20200515135133428.png) 在全局开启访达后边点击设置快捷键，我这里设置的是command+option+空格","categories":[{"name":"Mac","slug":"Mac","permalink":"http://lwblog.xyz/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://lwblog.xyz/tags/Mac/"}]},{"title":"sqlserver数据库还原单表数据操作","slug":"hello-world","date":"2020-05-08T14:53:07.000Z","updated":"2020-05-15T02:45:06.117Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"http://lwblog.xyz/posts/4a17b156.html","excerpt":"","text":"在系统数据和数据库数据备份或者升级的时候，我们总是全量的备份应用或者数据。在升级完成使用一段时间后突然间发现某张表的数据有问题，此时在全部的还原数据库的数据则不太合理，那如何只还原出现问题的这张表的数据呢？ 首先，我们需要将升级时全量备份的数据库还原成一个新的数据库，如何还原一个新的数据库，此处不在赘述，网上有好多。自我感觉还是参考sqlserver官方的还原说明或者参考SQL Server从BAK文件还原到新数据库 之后，我们选择刚刚还原完成的数据库使用如下的命令将ecology.dbo.hrmresource 所有的数据导入到demo.dbo.hrmresource_Test中 选中刚刚还原的数据库，执行如下的sql语句，执行完成后刷新可以看到demo中已经出现了需要还原的表单数据 1Select * into demo.dbo.hrmresource_test From ecology.dbo.hrmresource 两张表单对比,我这里的表单中没有数据，但是可以看到需要还原的demo库中对应的表单结构已经有了 最后，我们使用下列命令将原来的表进行删除，并把HtmlLabelInfo_Test 重命名为HtmlLabelInfo 1234//删除原有的表单,此处我的里边没有对用的表单,就没有执行这一步drop table [dbo].[Hrmresource]//表单重命名,或者在ssms操作工具中直接在actionsetting_test上摁下F2进行表单重命名EXEC sp_rename 'Hrmresource_test','Hrmresource' 或者是在navicat中可以直接右键选择重命名，对表单的名称进行更改 至此,在全量备份的情况下即可还原某一张表的数据。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://lwblog.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sqlserver","slug":"sqlserver","permalink":"http://lwblog.xyz/tags/sqlserver/"}]},{"title":"网络在在线传输工具 --- 奶牛快传","slug":"文件传输","date":"2020-05-08T14:53:07.000Z","updated":"2020-05-14T03:11:14.184Z","comments":true,"path":"posts/994d00c4.html","link":"","permalink":"http://lwblog.xyz/posts/994d00c4.html","excerpt":"","text":"1.奶牛快传1.1 免费超快的传文件工具奶牛快传是一款免费、无需注册即可直接使用的网页端大文件临时传输网盘服务。它提供了网页版、微信小程序、IOS以及安卓端。无论是办公文档、照片、还是电影视频通通都能轻松分享。 未注册用户则可最大传输 2GB 文件,默认保留7天，可以免费下载100次。支持加密、邮件和短信分享 1.2 奶牛快传的使用你只需在任何浏览器打开奶牛快传的网站，通过点击上传按钮或拖放文件即可开始上传，支持一次批量上传多个文件。 之后你就能获得文件的共享链接了。你只需将链接发给别人，对方就能直接通过浏览器下载了，对方并不需要注册登录，也无需下载 APP 等麻烦操作，实用性很强。同时，奶牛快传还提供了共享网址所对应的二维码以及微信小程序二维码，这样不管用手机还是电脑来下载文件都更方便。起码自己用电脑给手机发文件的场景也是经常会用到的。 1.3 奶牛快传注册账户还未体验过注册账户，待体验后在进行分享…..","categories":[{"name":"网络在在线传输工具","slug":"网络在在线传输工具","permalink":"http://lwblog.xyz/categories/%E7%BD%91%E7%BB%9C%E5%9C%A8%E5%9C%A8%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"奶牛快传","slug":"奶牛快传","permalink":"http://lwblog.xyz/tags/%E5%A5%B6%E7%89%9B%E5%BF%AB%E4%BC%A0/"},{"name":"文件传输","slug":"文件传输","permalink":"http://lwblog.xyz/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"网络在在线传输工具","slug":"网络在在线传输工具","permalink":"http://lwblog.xyz/tags/%E7%BD%91%E7%BB%9C%E5%9C%A8%E5%9C%A8%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/"}]},{"title":"油猴(Tampermonkey)常用脚本","slug":"油猴常用脚本","date":"2020-05-08T14:32:09.000Z","updated":"2020-05-13T08:09:31.020Z","comments":true,"path":"posts/44e1e43b.html","link":"","permalink":"http://lwblog.xyz/posts/44e1e43b.html","excerpt":"","text":"1.什么是油猴从英文翻译而来-Tampermonkey是一个捐赠软件用户脚本管理器，可用作浏览器扩展。该软件使用户能够添加和使用用户脚本，这些脚本是可用于修改网页的JavaScript程序 2.油猴下载地址 官网下载 谷歌商店3.常用插件3.1 批量下载网页图片 - Picviewer CE+Picviewer CE+ 是一款浏览器油猴脚本，可以将包含很多图片的网页变成图片浏览器，还能对图片进行翻转、旋转、放大，显示原始大图、收藏、批量保存，聚合所有分页大图，图片在线编辑等操作","categories":[],"tags":[{"name":"油猴","slug":"油猴","permalink":"http://lwblog.xyz/tags/%E6%B2%B9%E7%8C%B4/"},{"name":"Tampermonkey","slug":"Tampermonkey","permalink":"http://lwblog.xyz/tags/Tampermonkey/"}]}],"categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://lwblog.xyz/categories/mybatis/"},{"name":"学习计划","slug":"学习计划","permalink":"http://lwblog.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"java","slug":"java","permalink":"http://lwblog.xyz/categories/java/"},{"name":"google","slug":"google","permalink":"http://lwblog.xyz/categories/google/"},{"name":"Mac","slug":"Mac","permalink":"http://lwblog.xyz/categories/Mac/"},{"name":"数据库","slug":"数据库","permalink":"http://lwblog.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络在在线传输工具","slug":"网络在在线传输工具","permalink":"http://lwblog.xyz/categories/%E7%BD%91%E7%BB%9C%E5%9C%A8%E5%9C%A8%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://lwblog.xyz/tags/oracle/"},{"name":"mybatis","slug":"mybatis","permalink":"http://lwblog.xyz/tags/mybatis/"},{"name":"学习计划","slug":"学习计划","permalink":"http://lwblog.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"},{"name":"maven","slug":"maven","permalink":"http://lwblog.xyz/tags/maven/"},{"name":"activiti6.0","slug":"activiti6-0","permalink":"http://lwblog.xyz/tags/activiti6-0/"},{"name":"java","slug":"java","permalink":"http://lwblog.xyz/tags/java/"},{"name":"JDK1.8","slug":"JDK1-8","permalink":"http://lwblog.xyz/tags/JDK1-8/"},{"name":"调试","slug":"调试","permalink":"http://lwblog.xyz/tags/%E8%B0%83%E8%AF%95/"},{"name":"google diriver","slug":"google-diriver","permalink":"http://lwblog.xyz/tags/google-diriver/"},{"name":"Mac","slug":"Mac","permalink":"http://lwblog.xyz/tags/Mac/"},{"name":"sqlserver","slug":"sqlserver","permalink":"http://lwblog.xyz/tags/sqlserver/"},{"name":"奶牛快传","slug":"奶牛快传","permalink":"http://lwblog.xyz/tags/%E5%A5%B6%E7%89%9B%E5%BF%AB%E4%BC%A0/"},{"name":"文件传输","slug":"文件传输","permalink":"http://lwblog.xyz/tags/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"网络在在线传输工具","slug":"网络在在线传输工具","permalink":"http://lwblog.xyz/tags/%E7%BD%91%E7%BB%9C%E5%9C%A8%E5%9C%A8%E7%BA%BF%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7/"},{"name":"油猴","slug":"油猴","permalink":"http://lwblog.xyz/tags/%E6%B2%B9%E7%8C%B4/"},{"name":"Tampermonkey","slug":"Tampermonkey","permalink":"http://lwblog.xyz/tags/Tampermonkey/"}]}